# CLI 命令

VeCLI 支持几个内置命令，以帮助您管理会话、自定义界面和控制其行为。这些命令以正斜杠 (`/`)、at 符号 (`@`) 或感叹号 (`!`) 为前缀。

## 斜杠命令 (`/`)

斜杠命令提供对 CLI 本身的元级控制。

### 内置命令

- **`/bug`**
  - **描述：** 提交关于 VeCLI 的问题。默认情况下，问题在 VeCLI 的 GitHub 存储库内提交。您在 `/bug` 之后输入的字符串将成为提交的错误的标题。可以使用 `.ve/settings.json` 文件中的 `advanced.bugCommand` 设置修改默认的 `/bug` 行为。

- **`/chat`**
  - **描述：** 交互式地保存和恢复对话历史，以实现分支对话状态，或从后续会话中恢复先前的状态。
  - **子命令：**
    - **`save`**
      - **描述：** 保存当前对话历史。您必须添加一个 `<tag>` 来标识对话状态。
      - **用法：** `/chat save <tag>`
      - **关于检查点位置的详细信息：** 保存的聊天检查点的默认位置是：
        - Linux/macOS: `~/.ve/tmp/<project_hash>/`
        - Windows: `C:\Users\<YourUsername>\.ve\tmp\<project_hash>\`
        - 当您运行 `/chat list` 时，CLI 只会扫描这些特定目录以查找可用的检查点。
        - **注意：** 这些检查点用于手动保存和恢复对话状态。有关在文件修改之前创建的自动检查点，请参阅 [检查点文档](../checkpointing.md)。
    - **`resume`**
      - **描述：** 从先前的保存中恢复对话。
      - **用法：** `/chat resume <tag>`
    - **`list`**
      - **描述：** 列出可用于恢复聊天状态的标签。
    - **`delete`**
      - **描述：** 删除保存的对话检查点。
      - **用法：** `/chat delete <tag>`

- **`/clear`**
  - **描述：** 清除终端屏幕，包括 CLI 中可见的会话历史和回滚。根据确切的实现，底层会话数据（用于历史回忆）可能会被保留，但视觉显示会被清除。
  - **键盘快捷键：** 随时按 **Ctrl+L** 执行清除操作。

- **`/compress`**
  - **描述：** 用摘要替换整个聊天上下文。这可以节省用于未来任务的令牌，同时保留已发生事件的高级摘要。

- **`/copy`**
  - **描述：** 将 VeCLI 生成的最后一个输出复制到您的剪贴板，以便轻松共享或重用。
  - **注意：** 此命令需要安装特定于平台的剪贴板工具。
    - 在 Linux 上，它需要 `xclip` 或 `xsel`。您通常可以使用系统的包管理器安装它们。
    - 在 macOS 上，它需要 `pbcopy`，在 Windows 上，它需要 `clip`。这些工具通常在其各自的系统上预安装。

- **`/directory`** (或 **`/dir`**)
  - **描述：** 管理工作区目录以支持多目录。
  - **子命令：**
    - **`add`**:
      - **描述：** 将目录添加到工作区。路径可以是绝对路径或相对于当前工作目录的路径。此外，还支持从主目录引用。
      - **用法：** `/directory add <path1>,<path2>`
      - **注意：** 在限制性沙盒配置文件中禁用。如果您正在使用该配置文件，请在启动会话时改用 `--include-directories`。
    - **`show`**:
      - **描述：** 显示由 `/directory add` 和 `--include-directories` 添加的所有目录。
      - **用法：** `/directory show`

- **`/editor`**
  - **描述：** 打开一个对话框以选择支持的编辑器。

- **`/extensions`**
  - **描述：** 列出当前 VeCLI 会话中的所有活动扩展。请参阅 [VeCLI 扩展](../extension.md)。

- **`/help`** (或 **`/?`**)
  - **描述：** 显示有关 VeCLI 的帮助信息，包括可用命令及其用法。

- **`/mcp`**
  - **描述：** 列出配置的模型上下文协议 (MCP) 服务器、其连接状态、服务器详细信息和可用工具。
  - **子命令：**
    - **`desc`** 或 **`descriptions`**:
      - **描述：** 显示 MCP 服务器和工具的详细描述。
    - **`nodesc`** 或 **`nodescriptions`**:
      - **描述：** 隐藏工具描述，仅显示工具名称。
    - **`schema`**:
      - **描述：** 显示工具配置参数的完整 JSON 模式。
  - **键盘快捷键：** 随时按 **Ctrl+T** 在显示和隐藏工具描述之间切换。

- **`/memory`**
  - **描述：** 管理 AI 的指令上下文（从 `VE.md` 文件加载的分层内存）。
  - **子命令：**
    - **`add`**:
      - **描述：** 将以下文本添加到 AI 的内存中。用法: `/memory add <要记住的文本>`
    - **`show`**:
      - **描述：** 显示从所有 `VE.md` 文件加载的当前分层内存的完整连接内容。这使您可以检查提供给火山引擎模型的指令上下文。
    - **`refresh`**:
      - **描述：** 从配置位置（全局、项目/祖先和子目录）找到的所有 `VE.md` 文件中重新加载分层指令内存。此命令使用最新的 `VE.md` 内容更新模型。
    - **注意：** 有关 `VE.md` 文件如何贡献于分层内存的更多详细信息，请参阅 [CLI 配置文档](./configuration.md#4-ve.md-files-hierarchical-instructional-context)。

- **`/restore`**
  - **描述：** 将项目文件恢复到执行工具之前的状态。这对于撤销工具进行的文件编辑特别有用。如果在没有工具调用 ID 的情况下运行，它将列出可用于恢复的检查点。
  - **用法：** `/restore [tool_call_id]`
  - **注意：** 仅在使用 `--checkpointing` 选项调用 CLI 或通过 [设置](./configuration.md) 配置时可用。有关更多详细信息，请参阅 [检查点文档](../checkpointing.md)。

- **`/settings`**
  - **描述：** 打开设置编辑器以查看和修改 VeCLI 设置。
  - **详细信息：** 此命令提供了一个用户友好的界面，用于更改控制 VeCLI 行为和外观的设置。它等效于手动编辑 `.ve/settings.json` 文件，但具有验证和指导以防止错误。
  - **用法：** 只需运行 `/settings`，编辑器就会打开。然后您可以浏览或搜索特定设置，查看其当前值，并根据需要进行修改。某些设置的更改会立即应用，而其他设置则需要重新启动。

- **`/stats`**
  - **描述：** 显示当前 VeCLI 会话的详细统计信息，包括令牌使用量、缓存令牌节省（如果可用）和会话持续时间。注意：仅在使用缓存令牌时才显示缓存令牌信息，这在使用 API 密钥身份验证时会发生，但目前在使用 OAuth 身份验证时不会发生。

- [**`/theme`**](./themes.md)
  - **描述：** 打开一个对话框，让您可以更改 VeCLI 的视觉主题。

- **`/auth`**
  - **描述：** 打开一个对话框，让您可以更改身份验证方法。

- **`/about`**
  - **描述：** 显示版本信息。请在提交问题时分享此信息。

- [**`/tools`**](../tools/index.md)
  - **描述：** 显示当前在 VeCLI 中可用的工具列表。
  - **用法：** `/tools [desc]`
  - **子命令：**
    - **`desc`** 或 **`descriptions`**:
      - **描述：** 显示每个工具的详细描述，包括每个工具的名称及其提供给模型的完整描述。
    - **`nodesc`** 或 **`nodescriptions`**:
      - **描述：** 隐藏工具描述，仅显示工具名称。

- **`/privacy`**
  - **描述：** 显示隐私声明并允许用户选择是否同意为服务改进目的收集其数据。

- **`/quit`** (或 **`/exit`**)
  - **描述：** 退出 VeCLI。

- **`/vim`**
  - **描述：** 打开或关闭 vim 模式。启用 vim 模式时，输入区域支持 NORMAL 和 INSERT 模式下的 vim 风格导航和编辑命令。
  - **功能：**
    - **NORMAL 模式：** 使用 `h`、`j`、`k`、`l` 导航；使用 `w`、`b`、`e` 按单词跳转；使用 `0`、`$`、`^` 转到行首/行尾；使用 `G`（或 `gg` 转到第一行）转到特定行
    - **INSERT 模式：** 标准文本输入，按 escape 返回 NORMAL 模式
    - **编辑命令：** 使用 `x` 删除，使用 `c` 更改，使用 `i`、`a`、`o`、`O` 插入；复杂的操作如 `dd`、`cc`、`dw`、`cw`
    - **计数支持：** 用数字作为前缀命令（例如，`3h`、`5w`、`10G`）
    - **重复最后命令：** 使用 `.` 重复最后的编辑操作
    - **持久设置：** Vim 模式偏好设置保存到 `~/.ve/settings.json` 并在会话之间恢复
  - **状态指示器：** 启用时，在页脚中显示 `[NORMAL]` 或 `[INSERT]`

- **`/init`**
  - **描述：** 为了帮助用户轻松创建 `VE.md` 文件，此命令分析当前目录并生成一个量身定制的上下文文件，使他们更容易向火山引擎代理提供项目特定的指令。

### 自定义命令

有关快速入门，请参阅下面的 [示例](#example-a-pure-function-refactoring-command)。

自定义命令允许您将最喜欢或最常用的提示保存为 VeCLI 中的个人快捷方式。您可以创建特定于单个项目或在所有项目中全局可用的命令，从而简化您的工作流程并确保一致性。

#### 文件位置和优先级

VeCLI 从两个位置发现命令，按特定顺序加载：

1.  **用户命令 (全局):** 位于 `~/.ve/commands/`。这些命令在您处理的任何项目中都可用。
2.  **项目命令 (本地):** 位于 `~/.ve/commands/`。这些命令特定于当前项目，可以签入版本控制以与您的团队共享。

如果项目目录中的命令与用户目录中的命令同名，则**始终使用项目命令。** 这允许项目用特定于项目的版本覆盖全局命令。

#### 命名和命名空间

命令的名称由其相对于其 `commands` 目录的文件路径确定。子目录用于创建命名空间命令，路径分隔符 (`/` 或 `\\`) 转换为冒号 (`:`)。

- `~/.ve/commands/test.toml` 文件成为命令 `/test`。
- `<project>/.ve/commands/git/commit.toml` 文件成为命名空间命令 `/git:commit`。

#### TOML 文件格式 (v1)

您的命令定义文件必须以 TOML 格式编写并使用 `.toml` 文件扩展名。

##### 必需字段

- `prompt` (字符串): 执行命令时发送给火山引擎模型的提示。这可以是单行或多行字符串。

##### 可选字段

- `description` (字符串): 命令功能的简短一行描述。此文本将显示在 `/help` 菜单中您的命令旁边。**如果您省略此字段，将从文件名生成通用描述。**

#### 处理参数

自定义命令支持两种强大的参数处理方法。CLI 根据命令 `prompt` 的内容自动选择正确的方法。

##### 1. 使用 `{{args}}` 的上下文感知注入

如果您的 `prompt` 包含特殊占位符 `{{args}}`，CLI 将用用户在命令名称后键入的文本替换该占位符。

这种注入的行为取决于其使用位置：

**A. 原始注入 (在 Shell 命令外部)**

在提示的主体中使用时，参数会按用户键入的方式精确注入。

**示例 (`git/fix.toml`):**

```toml
# 通过: /git:fix "按钮未对齐" 调用

description = "为给定问题生成修复。"
prompt = "请为这里描述的问题提供代码修复: {{args}}。"
```

模型收到: `请为这里描述的问题提供代码修复: "按钮未对齐"。`

**B. 在 Shell 命令中使用参数 (在 `!{...}` 块内)**

当您在 shell 注入块 (`!{...}`) 内使用 `{{args}}` 时，参数在替换前会自动**进行 shell 转义**。这允许您安全地将参数传递给 shell 命令，确保生成的命令在语法上正确且安全，同时防止命令注入漏洞。

**示例 (`/grep-code.toml`):**

```toml
prompt = """
请总结模式 `{{args}}` 的发现。

搜索结果:
!{grep -r {{args}} .}
"""
```

当您运行 `/grep-code It's complicated` 时：

1. CLI 看到 `{{args}}` 在 `!{...}` 的内外都使用了。
2. 外部: 第一个 `{{args}}` 被原始替换为 `It's complicated`。
3. 内部: 第二个 `{{args}}` 被替换为转义版本（例如，在 Linux 上: `"It's complicated"`）。
4. 执行的命令是 `grep -r "It's complicated" .`。
5. CLI 在执行前会提示您确认这个确切的安全命令。
6. 最终提示被发送。

##### 2. 默认参数处理

如果您的 `prompt` **不**包含特殊占位符 `{{args}}`，CLI 使用默认行为来处理参数。

如果您为命令提供参数（例如，`/mycommand arg1`），CLI 会将您键入的完整命令附加到提示的末尾，用两个换行符分隔。这允许模型看到原始指令和您刚刚提供的特定参数。

如果您**不**提供任何参数（例如，`/mycommand`），提示会按原样发送给模型，不附加任何内容。

**示例 (`changelog.toml`):**

此示例展示了如何通过为模型定义角色、解释在哪里找到用户输入以及指定预期格式和行为来创建一个强大的命令。

```toml
# 在: <project>/.ve/commands/changelog.toml
# 通过: /changelog 1.2.0 added "支持默认参数解析。" 调用

description = "向项目的 CHANGELOG.md 文件添加新条目。"
prompt = """
# 任务: 更新变更日志

您是此软件项目的专家维护者。用户已调用一个命令来向变更日志添加新条目。

**用户的原始命令附加在您的指令下方。**

您的任务是从他们的输入中解析 `<version>`、`<change_type>` 和 `<message>`，并使用 `write_file` 工具正确更新 `CHANGELOG.md` 文件。

## 预期格式
命令遵循此格式: `/changelog <version> <type> <message>`
- `<type>` 必须是以下之一: "added"、"changed"、"fixed"、"removed"。

## 行为
1. 读取 `CHANGELOG.md` 文件。
2. 找到指定 `<version>` 的部分。
3. 在正确的 `<type>` 标题下添加 `<message>`。
4. 如果版本或类型部分不存在，则创建它。
5. 严格遵守 "Keep a Changelog" 格式。
"""
```

当您运行 `/changelog 1.2.0 added "新功能"` 时，发送给模型的最终文本将是原始提示，后跟两个换行符和您键入的命令。

##### 3. 使用 `!{...}` 执行 Shell 命令

您可以通过在 `prompt` 中直接执行 shell 命令并注入其输出，使您的命令具有动态性。这对于从本地环境收集上下文（如读取文件内容或检查 Git 状态）非常理想。

当自定义命令尝试执行 shell 命令时，VeCLI 现在会在继续之前提示您确认。这是一项安全措施，以确保只能运行预期的命令。

**工作原理:**

1.  **注入命令：** 使用 `!{...}` 语法。
2.  **参数替换：** 如果 `{{args}}` 存在于块内，则会自动进行 shell 转义（参见上面的 [上下文感知注入](#1-context-aware-injection-with-args)）。
3.  **健壮解析：** 解析器可以正确处理包含嵌套大括号的复杂 shell 命令，例如 JSON 有效载荷。**注意：** `!{...}` 内的内容必须具有平衡的大括号 (`{` 和 `}`)。如果需要执行包含不平衡大括号的命令，请考虑将它包装在外部脚本文件中，并在 `!{...}` 块中调用该脚本。
4.  **安全检查和确认：** CLI 对最终的、已解析的命令（在参数转义和替换后）执行安全检查。将出现一个对话框，显示要执行的确切命令。
5.  **执行和错误报告：** 命令被执行。如果命令失败，注入到提示中的输出将包括错误消息 (stderr)，后跟状态行，例如，`[Shell 命令以代码 1 退出]`。这有助于模型理解失败的上下文。

**示例 (`git/commit.toml`):**

此命令获取暂存的 git diff，并使用它来要求模型编写提交消息。

````toml
# 在: <project>/.ve/commands/git/commit.toml
# 通过: /git:commit 调用

description = "基于暂存的更改生成 Git 提交消息。"

# 提示使用 !{...} 执行命令并注入其输出。
prompt = """
请根据以下 git diff 生成一个 Conventional Commit 消息：

```diff
!{git diff --staged}
```

"""

````

当您运行 `/git:commit` 时，CLI 首先执行 `git diff --staged`，然后在将最终的完整提示发送给模型之前，用该命令的输出替换 `!{git diff --staged}`。

##### 4. 使用 `@{...}` 注入文件内容

您可以使用 `@{...}` 语法直接将文件或目录列表的内容嵌入到您的提示中。这对于创建对特定文件进行操作的命令非常有用。

**工作原理:**

- **文件注入**: `@{path/to/file.txt}` 被 `file.txt` 的内容替换。
- **多模态支持**: 如果路径指向受支持的图像（例如 PNG、JPEG）、PDF、音频或视频文件，它将被正确编码并作为多模态输入注入。其他二进制文件会被优雅地处理并跳过。
- **目录列表**: `@{path/to/dir}` 被遍历，目录内及其所有子目录中的每个文件都会插入到提示中。如果启用了，则会遵守 `.gitignore` 和 `.veignore`。
- **工作区感知**: 命令会在当前目录和任何其他工作区目录中搜索路径。如果在工作区内，绝对路径是允许的。
- **处理顺序**: 使用 `@{...}` 进行的文件内容注入在 shell 命令 (`!{...}`) 和参数替换 (`{{args}}`) 之前进行处理。
- **解析**: 解析器要求 `@{...}` 内的内容（路径）具有平衡的大括号 (`{` 和 `}`)。

**示例 (`review.toml`):**

此命令注入一个 _固定_ 的最佳实践文件 (`docs/best-practices.md`) 的内容，并使用用户的参数为审查提供上下文。

```toml
# 在: <project>/.ve/commands/review.toml
# 通过: /review FileCommandLoader.ts 调用

description = "使用最佳实践指南审查提供的上下文。"
prompt = """
您是一位专家代码审查员。

您的任务是审查 {{args}}。

在提供您的审查时，请使用以下最佳实践：

@{docs/best-practices.md}
"""
```

当您运行 `/review FileCommandLoader.ts` 时，`@{docs/best-practices.md}` 占位符被该文件的内容替换，`{{args}}` 被您提供的文本替换，然后将最终提示发送给模型。

---

#### 示例: "纯函数" 重构命令

让我们创建一个全局命令，要求模型重构一段代码。

**1. 创建文件和目录:**

首先，确保用户命令目录存在，然后创建一个 `refactor` 子目录用于组织和最终的 TOML 文件。

```bash
mkdir -p ~/.ve/commands/refactor
touch ~/.ve/commands/refactor/pure.toml
```

**2. 将内容添加到文件中:**

在您的编辑器中打开 `~/.ve/commands/refactor/pure.toml` 并添加以下内容。我们包括了可选的 `description` 以获得最佳实践。

```toml
# 在: ~/.ve/commands/refactor/pure.toml
# 此命令将通过: /refactor:pure 调用

description = "要求模型将当前上下文重构为纯函数。"

prompt = """
请分析我在当前上下文中提供的代码。
将其重构为纯函数。

您的响应应包括：
1. 重构后的纯函数代码块。
2. 对您所做的关键更改及其如何有助于纯净性的简要解释。
"""
```

**3. 运行命令:**

就是这样！您现在可以在 CLI 中运行您的命令。首先，您可能会将一个文件添加到上下文中，然后调用您的命令：

```
> @my-messy-function.js
> /refactor:pure
```

VeCLI 然后将执行在您的 TOML 文件中定义的多行提示。

## At 命令 (`@`)

At 命令用于将文件或目录的内容作为您对火山引擎的提示的一部分包含进来。这些命令包括 git 感知过滤。

- **`@<文件或目录的路径>`**
  - **描述：** 将指定文件或文件的内容注入到您的当前提示中。这对于询问有关特定代码、文本或文件集合的问题很有用。
  - **示例：**
    - `@path/to/your/file.txt 解释这段文本。`
    - `@src/my_project/ 总结此目录中的代码。`
    - `这个文件是关于什么的？ @README.md`
  - **详细信息：**
    - 如果提供了单个文件的路径，则读取该文件的内容。
    - 如果提供了目录的路径，则命令会尝试读取该目录及其任何子目录中的文件内容。
    - 路径中的空格应使用反斜杠进行转义（例如，`@My\\ Documents/file.txt`）。
    - 该命令在内部使用 `read_many_files` 工具。内容被获取，然后在发送到  模型之前插入到您的查询中。
    - **Git 感知过滤：** 默认情况下，git 忽略的文件（如 `node_modules/`、`dist/`、`.env`、`.git/`）会被排除。可以通过 `context.fileFiltering` 设置更改此行为。
    - **文件类型：** 该命令适用于基于文本的文件。虽然它可能会尝试读取任何文件，但底层的 `read_many_files` 工具可能会跳过或截断二进制文件或非常大的文件，以确保性能和相关性。该工具会指示哪些文件被跳过。
  - **输出：** CLI 将显示一条工具调用消息，指示使用了 `read_many_files`，以及一条详细说明状态和处理路径的消息。

- **`@` (单独的 at 符号)
  - **描述：** 如果您输入一个单独的 `@` 符号而没有路径，查询将按原样传递给火山引擎模型。如果您在提示中特别谈论 `@` 符号，这可能很有用。

### `@` 命令的错误处理

- 如果 `@` 之后指定的路径未找到或无效，将显示错误消息，并且查询可能不会发送到  模型，或者会在没有文件内容的情况下发送。
- 如果 `read_many_files` 工具遇到错误（例如，权限问题），也会报告此错误。

## Shell 模式和直通命令 (`!`)

`!` 前缀允许您直接从 VeCLI 内与系统的 shell 交互。

- **`!<shell_command>`**
  - **描述：** 使用 `bash` 在 Linux/macOS 上或使用 `cmd.exe` 在 Windows 上执行给定的 `<shell_command>`。命令的任何输出或错误都会显示在终端中。
  - **示例：**
    - `!ls -la` (执行 `ls -la` 并返回 VeCLI)
    - `!git status` (执行 `git status` 并返回 VeCLI)

- **`!` (切换 shell 模式)**
  - **描述：** 单独输入 `!` 可切换 shell 模式。
    - **进入 shell 模式：**
      - 激活时，shell 模式使用不同的着色和 "Shell 模式指示器"。
      - 在 shell 模式下，您键入的文本直接解释为 shell 命令。
    - **退出 shell 模式：**
      - 退出时，UI 恢复到标准外观，正常的 VeCLI 行为恢复。

- **所有 `!` 用法的注意事项：** 您在 shell 模式下执行的命令具有与直接在终端中运行它们相同的权限和影响。

- **环境变量：** 当通过 `!` 或在 shell 模式下执行命令时，`GEMINI_CLI=1` 环境变量会在子进程的环境中设置。这允许脚本或工具检测它们是否在 VeCLI 内运行。