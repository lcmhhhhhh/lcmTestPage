"use strict";(self.webpackChunklcm_test_page=self.webpackChunklcm_test_page||[]).push([["9440"],{1537:function(e,d,r){r.r(d),r.d(d,{default:()=>a});var n=r(5893),s=r(65);function i(e){let d=Object.assign({h1:"h1",a:"a",p:"p",code:"code",h2:"h2",pre:"pre",h3:"h3",ul:"ul",li:"li",strong:"strong",ol:"ol"},(0,s.ah)(),e.components);return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsxs)(d.h1,{id:"内存导入处理器",children:["内存导入处理器",(0,n.jsx)(d.a,{className:"header-anchor","aria-hidden":"true",href:"#内存导入处理器",children:"#"})]}),"\n",(0,n.jsxs)(d.p,{children:["内存导入处理器是一项功能，允许您通过使用 ",(0,n.jsx)(d.code,{children:"@file.md"})," 语法从其他文件导入内容来模块化您的 VE.md 文件。"]}),"\n",(0,n.jsxs)(d.h2,{id:"概述",children:["概述",(0,n.jsx)(d.a,{className:"header-anchor","aria-hidden":"true",href:"#概述",children:"#"})]}),"\n",(0,n.jsx)(d.p,{children:"此功能使您能够将大型 VE.md 文件分解为更小、更易于管理的组件，这些组件可以在不同的上下文中重复使用。导入处理器支持相对路径和绝对路径，并内置了安全功能以防止循环导入并确保文件访问安全。"}),"\n",(0,n.jsxs)(d.h2,{id:"语法",children:["语法",(0,n.jsx)(d.a,{className:"header-anchor","aria-hidden":"true",href:"#语法",children:"#"})]}),"\n",(0,n.jsxs)(d.p,{children:["使用 ",(0,n.jsx)(d.code,{children:"@"})," 符号后跟要导入的文件路径："]}),"\n",(0,n.jsx)(d.pre,{children:(0,n.jsx)(d.code,{className:"language-markdown",children:"# 主 VE.md 文件\n\n这是主要内容。\n\n@./components/instructions.md\n\n更多内容在这里。\n\n@./shared/configuration.md\n"})}),"\n",(0,n.jsxs)(d.h2,{id:"支持的路径格式",children:["支持的路径格式",(0,n.jsx)(d.a,{className:"header-anchor","aria-hidden":"true",href:"#支持的路径格式",children:"#"})]}),"\n",(0,n.jsxs)(d.h3,{id:"相对路径",children:["相对路径",(0,n.jsx)(d.a,{className:"header-anchor","aria-hidden":"true",href:"#相对路径",children:"#"})]}),"\n",(0,n.jsxs)(d.ul,{children:["\n",(0,n.jsxs)(d.li,{children:[(0,n.jsx)(d.code,{children:"@./file.md"})," - 从同一目录导入"]}),"\n",(0,n.jsxs)(d.li,{children:[(0,n.jsx)(d.code,{children:"@../file.md"})," - 从父目录导入"]}),"\n",(0,n.jsxs)(d.li,{children:[(0,n.jsx)(d.code,{children:"@./components/file.md"})," - 从子目录导入"]}),"\n"]}),"\n",(0,n.jsxs)(d.h3,{id:"绝对路径",children:["绝对路径",(0,n.jsx)(d.a,{className:"header-anchor","aria-hidden":"true",href:"#绝对路径",children:"#"})]}),"\n",(0,n.jsxs)(d.ul,{children:["\n",(0,n.jsxs)(d.li,{children:[(0,n.jsx)(d.code,{children:"@/absolute/path/to/file.md"})," - 使用绝对路径导入"]}),"\n"]}),"\n",(0,n.jsxs)(d.h2,{id:"示例",children:["示例",(0,n.jsx)(d.a,{className:"header-anchor","aria-hidden":"true",href:"#示例",children:"#"})]}),"\n",(0,n.jsxs)(d.h3,{id:"基本导入",children:["基本导入",(0,n.jsx)(d.a,{className:"header-anchor","aria-hidden":"true",href:"#基本导入",children:"#"})]}),"\n",(0,n.jsx)(d.pre,{children:(0,n.jsx)(d.code,{className:"language-markdown",children:"# 我的 VE.md\n\n欢迎来到我的项目！\n\n@./getting-started.md\n\n## 功能\n\n@./features/overview.md\n"})}),"\n",(0,n.jsxs)(d.h3,{id:"嵌套导入",children:["嵌套导入",(0,n.jsx)(d.a,{className:"header-anchor","aria-hidden":"true",href:"#嵌套导入",children:"#"})]}),"\n",(0,n.jsx)(d.p,{children:"导入的文件本身可以包含导入，从而创建嵌套结构："}),"\n",(0,n.jsx)(d.pre,{children:(0,n.jsx)(d.code,{className:"language-markdown",children:"# main.md\n\n@./header.md\n@./content.md\n@./footer.md\n"})}),"\n",(0,n.jsx)(d.pre,{children:(0,n.jsx)(d.code,{className:"language-markdown",children:"# header.md\n\n# 项目标题\n\n@./shared/title.md\n"})}),"\n",(0,n.jsxs)(d.h2,{id:"安全功能",children:["安全功能",(0,n.jsx)(d.a,{className:"header-anchor","aria-hidden":"true",href:"#安全功能",children:"#"})]}),"\n",(0,n.jsxs)(d.h3,{id:"循环导入检测",children:["循环导入检测",(0,n.jsx)(d.a,{className:"header-anchor","aria-hidden":"true",href:"#循环导入检测",children:"#"})]}),"\n",(0,n.jsx)(d.p,{children:"处理器会自动检测并防止循环导入："}),"\n",(0,n.jsx)(d.pre,{children:(0,n.jsx)(d.code,{className:"language-markdown",children:"# file-a.md\n\n@./file-b.md\n\n# file-b.md\n\n@./file-a.md \x3c!-- 这将被检测并阻止 --\x3e\n"})}),"\n",(0,n.jsxs)(d.h3,{id:"文件访问安全",children:["文件访问安全",(0,n.jsx)(d.a,{className:"header-anchor","aria-hidden":"true",href:"#文件访问安全",children:"#"})]}),"\n",(0,n.jsxs)(d.p,{children:[(0,n.jsx)(d.code,{children:"validateImportPath"})," 函数确保仅允许从指定目录导入，防止访问允许范围之外的敏感文件。"]}),"\n",(0,n.jsxs)(d.h3,{id:"最大导入深度",children:["最大导入深度",(0,n.jsx)(d.a,{className:"header-anchor","aria-hidden":"true",href:"#最大导入深度",children:"#"})]}),"\n",(0,n.jsx)(d.p,{children:"为了防止无限递归，有一个可配置的最大导入深度（默认值：5 级）。"}),"\n",(0,n.jsxs)(d.h2,{id:"错误处理",children:["错误处理",(0,n.jsx)(d.a,{className:"header-anchor","aria-hidden":"true",href:"#错误处理",children:"#"})]}),"\n",(0,n.jsxs)(d.h3,{id:"缺少文件",children:["缺少文件",(0,n.jsx)(d.a,{className:"header-anchor","aria-hidden":"true",href:"#缺少文件",children:"#"})]}),"\n",(0,n.jsx)(d.p,{children:"如果引用的文件不存在，导入将优雅地失败，并在输出中显示错误注释。"}),"\n",(0,n.jsxs)(d.h3,{id:"文件访问错误",children:["文件访问错误",(0,n.jsx)(d.a,{className:"header-anchor","aria-hidden":"true",href:"#文件访问错误",children:"#"})]}),"\n",(0,n.jsx)(d.p,{children:"权限问题或其他文件系统错误会通过适当的错误消息优雅地处理。"}),"\n",(0,n.jsxs)(d.h2,{id:"代码区域检测",children:["代码区域检测",(0,n.jsx)(d.a,{className:"header-anchor","aria-hidden":"true",href:"#代码区域检测",children:"#"})]}),"\n",(0,n.jsxs)(d.p,{children:["导入处理器使用 ",(0,n.jsx)(d.code,{children:"marked"})," 库来检测代码块和内联代码片段，确保这些区域内的 ",(0,n.jsx)(d.code,{children:"@"})," 导入被正确忽略。这提供了对嵌套代码块和复杂 Markdown 结构的稳健处理。"]}),"\n",(0,n.jsxs)(d.h2,{id:"导入树结构",children:["导入树结构",(0,n.jsx)(d.a,{className:"header-anchor","aria-hidden":"true",href:"#导入树结构",children:"#"})]}),"\n",(0,n.jsxs)(d.p,{children:["处理器返回一个导入树，显示导入文件的层次结构，类似于 Claude 的 ",(0,n.jsx)(d.code,{children:"/memory"})," 功能。这有助于用户通过显示读取了哪些文件及其导入关系来调试他们的 VE.md 文件。"]}),"\n",(0,n.jsx)(d.p,{children:"示例树结构："}),"\n",(0,n.jsx)(d.pre,{children:(0,n.jsx)(d.code,{children:"Memory Files\n L project: VE.md\n            L a.md\n              L b.md\n                L c.md\n              L d.md\n                L e.md\n                  L f.md\n            L included.md\n"})}),"\n",(0,n.jsx)(d.p,{children:"该树保留了文件被导入的顺序，并显示了完整的导入链以用于调试目的。"}),"\n",(0,n.jsxs)(d.h2,{id:"与-claude-code-的-memory-claudemd-方法的比较",children:["与 Claude Code 的 ",(0,n.jsx)(d.code,{children:"/memory"})," (",(0,n.jsx)(d.code,{children:"claude.md"}),") 方法的比较",(0,n.jsx)(d.a,{className:"header-anchor","aria-hidden":"true",href:"#与-claude-code-的-memory-claudemd-方法的比较",children:"#"})]}),"\n",(0,n.jsxs)(d.p,{children:["Claude Code 的 ",(0,n.jsx)(d.code,{children:"/memory"})," 功能（如 ",(0,n.jsx)(d.code,{children:"claude.md"})," 中所示）通过连接所有包含的文件生成一个扁平的线性文档，始终用清晰的注释和路径名称标记文件边界。它不显式呈现导入层次结构，但 LLM 会接收到所有文件内容和路径，如果需要，这足以重建层次结构。"]}),"\n",(0,n.jsx)(d.p,{children:"注意：导入树主要用于开发过程中的清晰性，对 LLM 的消费影响有限。"}),"\n",(0,n.jsxs)(d.h2,{id:"api-参考",children:["API 参考",(0,n.jsx)(d.a,{className:"header-anchor","aria-hidden":"true",href:"#api-参考",children:"#"})]}),"\n",(0,n.jsxs)(d.h3,{id:"processimportscontent-basepath-debugmode-importstate",children:[(0,n.jsx)(d.code,{children:"processImports(content, basePath, debugMode?, importState?)"}),(0,n.jsx)(d.a,{className:"header-anchor","aria-hidden":"true",href:"#processimportscontent-basepath-debugmode-importstate",children:"#"})]}),"\n",(0,n.jsx)(d.p,{children:"处理 VE.md 内容中的导入语句。"}),"\n",(0,n.jsx)(d.p,{children:(0,n.jsx)(d.strong,{children:"参数:"})}),"\n",(0,n.jsxs)(d.ul,{children:["\n",(0,n.jsxs)(d.li,{children:[(0,n.jsx)(d.code,{children:"content"})," (string): 要处理导入的内容"]}),"\n",(0,n.jsxs)(d.li,{children:[(0,n.jsx)(d.code,{children:"basePath"})," (string): 当前文件所在的目录路径"]}),"\n",(0,n.jsxs)(d.li,{children:[(0,n.jsx)(d.code,{children:"debugMode"})," (boolean, optional): 是否启用调试日志（默认值：false）"]}),"\n",(0,n.jsxs)(d.li,{children:[(0,n.jsx)(d.code,{children:"importState"})," (ImportState, optional): 用于防止循环导入的状态跟踪"]}),"\n"]}),"\n",(0,n.jsxs)(d.p,{children:[(0,n.jsx)(d.strong,{children:"返回:"})," Promise"," - 包含处理后的内容和导入树的对象"]}),"\n",(0,n.jsxs)(d.h3,{id:"processimportsresult",children:[(0,n.jsx)(d.code,{children:"ProcessImportsResult"}),(0,n.jsx)(d.a,{className:"header-anchor","aria-hidden":"true",href:"#processimportsresult",children:"#"})]}),"\n",(0,n.jsx)(d.pre,{children:(0,n.jsx)(d.code,{className:"language-typescript",children:"interface ProcessImportsResult {\n  content: string; // 解析了导入的处理后内容\n  importTree: MemoryFile; // 显示导入层次结构的树结构\n}\n"})}),"\n",(0,n.jsxs)(d.h3,{id:"memoryfile",children:[(0,n.jsx)(d.code,{children:"MemoryFile"}),(0,n.jsx)(d.a,{className:"header-anchor","aria-hidden":"true",href:"#memoryfile",children:"#"})]}),"\n",(0,n.jsx)(d.pre,{children:(0,n.jsx)(d.code,{className:"language-typescript",children:"interface MemoryFile {\n  path: string; // 文件路径\n  imports?: MemoryFile[]; // 直接导入，按导入顺序排列\n}\n"})}),"\n",(0,n.jsxs)(d.h3,{id:"validateimportpathimportpath-basepath-alloweddirectories",children:[(0,n.jsx)(d.code,{children:"validateImportPath(importPath, basePath, allowedDirectories)"}),(0,n.jsx)(d.a,{className:"header-anchor","aria-hidden":"true",href:"#validateimportpathimportpath-basepath-alloweddirectories",children:"#"})]}),"\n",(0,n.jsx)(d.p,{children:"验证导入路径以确保它们是安全的并且在允许的目录内。"}),"\n",(0,n.jsx)(d.p,{children:(0,n.jsx)(d.strong,{children:"参数:"})}),"\n",(0,n.jsxs)(d.ul,{children:["\n",(0,n.jsxs)(d.li,{children:[(0,n.jsx)(d.code,{children:"importPath"})," (string): 要验证的导入路径"]}),"\n",(0,n.jsxs)(d.li,{children:[(0,n.jsx)(d.code,{children:"basePath"})," (string): 解析相对路径的基本目录"]}),"\n",(0,n.jsxs)(d.li,{children:[(0,n.jsx)(d.code,{children:"allowedDirectories"})," (string[]): 允许的目录路径数组"]}),"\n"]}),"\n",(0,n.jsxs)(d.p,{children:[(0,n.jsx)(d.strong,{children:"返回:"})," boolean - 导入路径是否有效"]}),"\n",(0,n.jsxs)(d.h3,{id:"findprojectrootstartdir",children:[(0,n.jsx)(d.code,{children:"findProjectRoot(startDir)"}),(0,n.jsx)(d.a,{className:"header-anchor","aria-hidden":"true",href:"#findprojectrootstartdir",children:"#"})]}),"\n",(0,n.jsxs)(d.p,{children:["通过从给定的起始目录向上搜索 ",(0,n.jsx)(d.code,{children:".git"})," 目录来查找项目根目录。实现为一个 ",(0,n.jsx)(d.strong,{children:"async"})," 函数，使用非阻塞文件系统 API 以避免阻塞 Node.js 事件循环。"]}),"\n",(0,n.jsx)(d.p,{children:(0,n.jsx)(d.strong,{children:"参数:"})}),"\n",(0,n.jsxs)(d.ul,{children:["\n",(0,n.jsxs)(d.li,{children:[(0,n.jsx)(d.code,{children:"startDir"})," (string): 开始搜索的目录"]}),"\n"]}),"\n",(0,n.jsxs)(d.p,{children:[(0,n.jsx)(d.strong,{children:"返回:"})," Promise"," - 项目根目录（如果未找到 ",(0,n.jsx)(d.code,{children:".git"}),"，则为起始目录）"]}),"\n",(0,n.jsxs)(d.h2,{id:"最佳实践",children:["最佳实践",(0,n.jsx)(d.a,{className:"header-anchor","aria-hidden":"true",href:"#最佳实践",children:"#"})]}),"\n",(0,n.jsxs)(d.ol,{children:["\n",(0,n.jsxs)(d.li,{children:[(0,n.jsx)(d.strong,{children:"使用描述性的文件名"})," 为导入的组件命名"]}),"\n",(0,n.jsxs)(d.li,{children:[(0,n.jsx)(d.strong,{children:"保持导入浅层"})," - 避免深度嵌套的导入链"]}),"\n",(0,n.jsxs)(d.li,{children:[(0,n.jsx)(d.strong,{children:"记录您的结构"})," - 维护导入文件的清晰层次结构"]}),"\n",(0,n.jsxs)(d.li,{children:[(0,n.jsx)(d.strong,{children:"测试您的导入"})," - 确保所有引用的文件都存在且可访问"]}),"\n",(0,n.jsxs)(d.li,{children:[(0,n.jsx)(d.strong,{children:"尽可能使用相对路径"})," 以获得更好的可移植性"]}),"\n"]}),"\n",(0,n.jsxs)(d.h2,{id:"故障排除",children:["故障排除",(0,n.jsx)(d.a,{className:"header-anchor","aria-hidden":"true",href:"#故障排除",children:"#"})]}),"\n",(0,n.jsxs)(d.h3,{id:"常见问题",children:["常见问题",(0,n.jsx)(d.a,{className:"header-anchor","aria-hidden":"true",href:"#常见问题",children:"#"})]}),"\n",(0,n.jsxs)(d.ol,{children:["\n",(0,n.jsxs)(d.li,{children:[(0,n.jsx)(d.strong,{children:"导入不工作"}),": 检查文件是否存在以及路径是否正确"]}),"\n",(0,n.jsxs)(d.li,{children:[(0,n.jsx)(d.strong,{children:"循环导入警告"}),": 检查您的导入结构是否存在循环引用"]}),"\n",(0,n.jsxs)(d.li,{children:[(0,n.jsx)(d.strong,{children:"权限错误"}),": 确保文件可读且在允许的目录内"]}),"\n",(0,n.jsxs)(d.li,{children:[(0,n.jsx)(d.strong,{children:"路径解析问题"}),": 如果相对路径无法正确解析，请使用绝对路径"]}),"\n"]}),"\n",(0,n.jsxs)(d.h3,{id:"调试模式",children:["调试模式",(0,n.jsx)(d.a,{className:"header-anchor","aria-hidden":"true",href:"#调试模式",children:"#"})]}),"\n",(0,n.jsx)(d.p,{children:"启用调试模式以查看导入过程的详细日志："}),"\n",(0,n.jsx)(d.pre,{children:(0,n.jsx)(d.code,{className:"language-typescript",children:"const result = await processImports(content, basePath, true);\n"})})]})}function h(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:d}=Object.assign({},(0,s.ah)(),e.components);return d?(0,n.jsx)(d,{...e,children:(0,n.jsx)(i,{...e})}):i(e)}let a=h;h.__RSPRESS_PAGE_META={},h.__RSPRESS_PAGE_META["zh%2Fcore%2Fmemport.md"]={toc:[{text:"概述",id:"概述",depth:2},{text:"语法",id:"语法",depth:2},{text:"支持的路径格式",id:"支持的路径格式",depth:2},{text:"相对路径",id:"相对路径",depth:3},{text:"绝对路径",id:"绝对路径",depth:3},{text:"示例",id:"示例",depth:2},{text:"基本导入",id:"基本导入",depth:3},{text:"嵌套导入",id:"嵌套导入",depth:3},{text:"安全功能",id:"安全功能",depth:2},{text:"循环导入检测",id:"循环导入检测",depth:3},{text:"文件访问安全",id:"文件访问安全",depth:3},{text:"最大导入深度",id:"最大导入深度",depth:3},{text:"错误处理",id:"错误处理",depth:2},{text:"缺少文件",id:"缺少文件",depth:3},{text:"文件访问错误",id:"文件访问错误",depth:3},{text:"代码区域检测",id:"代码区域检测",depth:2},{text:"导入树结构",id:"导入树结构",depth:2},{text:"与 Claude Code 的 `/memory` (`claude.md`) 方法的比较",id:"与-claude-code-的-memory-claudemd-方法的比较",depth:2},{text:"API 参考",id:"api-参考",depth:2},{text:"`processImports(content, basePath, debugMode?, importState?)`",id:"processimportscontent-basepath-debugmode-importstate",depth:3},{text:"`ProcessImportsResult`",id:"processimportsresult",depth:3},{text:"`MemoryFile`",id:"memoryfile",depth:3},{text:"`validateImportPath(importPath, basePath, allowedDirectories)`",id:"validateimportpathimportpath-basepath-alloweddirectories",depth:3},{text:"`findProjectRoot(startDir)`",id:"findprojectrootstartdir",depth:3},{text:"最佳实践",id:"最佳实践",depth:2},{text:"故障排除",id:"故障排除",depth:2},{text:"常见问题",id:"常见问题",depth:3},{text:"调试模式",id:"调试模式",depth:3}],title:"内存导入处理器",headingTitle:"内存导入处理器",frontmatter:{}}}}]);