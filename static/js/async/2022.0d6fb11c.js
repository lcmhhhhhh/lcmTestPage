"use strict";(self.webpackChunklcm_test_page=self.webpackChunklcm_test_page||[]).push([["2022"],{439:function(e,n,s){s.r(n),s.d(n,{default:()=>h});var r=s(5893),d=s(65);function c(e){let n=Object.assign({h1:"h1",a:"a",p:"p",h2:"h2",ul:"ul",li:"li",strong:"strong",code:"code",h3:"h3",ol:"ol",h4:"h4",pre:"pre"},(0,d.ah)(),e.components);return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsxs)(n.h1,{id:"使用-vecli-的-mcp-服务器",children:["使用 VeCLI 的 MCP 服务器",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#使用-vecli-的-mcp-服务器",children:"#"})]}),"\n",(0,r.jsx)(n.p,{children:"本文档提供了在 VeCLI 中配置和使用模型上下文协议 (MCP) 服务器的指南。"}),"\n",(0,r.jsxs)(n.h2,{id:"什么是-mcp-服务器",children:["什么是 MCP 服务器？",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#什么是-mcp-服务器",children:"#"})]}),"\n",(0,r.jsx)(n.p,{children:"MCP 服务器是一个通过模型上下文协议向 VeCLI 公开工具和资源的应用程序，使其能够与外部系统和数据源交互。MCP 服务器充当 Vecli 模型与您的本地环境或其他服务（如 API）之间的桥梁。"}),"\n",(0,r.jsx)(n.p,{children:"MCP 服务器使 VeCLI 能够："}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"发现工具："})," 通过标准化的模式定义列出可用的工具、其描述和参数。"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"执行工具："})," 使用定义的参数调用特定工具并接收结构化响应。"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"访问资源："})," 从特定资源读取数据（尽管 VeCLI 主要专注于工具执行）。"]}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"通过 MCP 服务器，您可以扩展 VeCLI 的功能，使其能够执行超出其内置功能的操作，例如与数据库、API、自定义脚本或专用工作流交互。"}),"\n",(0,r.jsxs)(n.h2,{id:"核心集成架构",children:["核心集成架构",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#核心集成架构",children:"#"})]}),"\n",(0,r.jsxs)(n.p,{children:["VeCLI 通过内置在核心包 (",(0,r.jsx)(n.code,{children:"packages/core/src/tools/"}),") 中的复杂发现和执行系统与 MCP 服务器集成："]}),"\n",(0,r.jsxs)(n.h3,{id:"发现阶段-mcp-clientts",children:["发现阶段 (",(0,r.jsx)(n.code,{children:"mcp-client.ts"}),")",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#发现阶段-mcp-clientts",children:"#"})]}),"\n",(0,r.jsxs)(n.p,{children:["发现过程由 ",(0,r.jsx)(n.code,{children:"discoverMcpTools()"})," 编排，该过程："]}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"遍历配置的服务器"})," 从您的 ",(0,r.jsx)(n.code,{children:"settings.json"})," ",(0,r.jsx)(n.code,{children:"mcpServers"})," 配置中"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"建立连接"})," 使用适当的传输机制（Stdio、SSE 或可流式 HTTP）"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"获取工具定义"})," 使用 MCP 协议从每个服务器获取"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"清理和验证"})," 工具模式以确保与 Vecli API 兼容"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"注册工具"})," 在全局工具注册表中，并解决冲突"]}),"\n"]}),"\n",(0,r.jsxs)(n.h3,{id:"执行层-mcp-toolts",children:["执行层 (",(0,r.jsx)(n.code,{children:"mcp-tool.ts"}),")",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#执行层-mcp-toolts",children:"#"})]}),"\n",(0,r.jsxs)(n.p,{children:["每个发现的 MCP 工具都包装在 ",(0,r.jsx)(n.code,{children:"DiscoveredMCPTool"})," 实例中，该实例："]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"处理确认逻辑"})," 基于服务器信任设置和用户偏好"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"管理工具执行"})," 通过使用正确的参数调用 MCP 服务器"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"处理响应"})," 用于 LLM 上下文和用户显示"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"维护连接状态"})," 并处理超时"]}),"\n"]}),"\n",(0,r.jsxs)(n.h3,{id:"传输机制",children:["传输机制",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#传输机制",children:"#"})]}),"\n",(0,r.jsx)(n.p,{children:"VeCLI 支持三种 MCP 传输类型："}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Stdio 传输："})," 生成子进程并通过 stdin/stdout 通信"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"SSE 传输："})," 连接到服务器发送事件端点"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"可流式 HTTP 传输："})," 使用 HTTP 流进行通信"]}),"\n"]}),"\n",(0,r.jsxs)(n.h2,{id:"如何设置您的-mcp-服务器",children:["如何设置您的 MCP 服务器",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#如何设置您的-mcp-服务器",children:"#"})]}),"\n",(0,r.jsxs)(n.p,{children:["VeCLI 使用 ",(0,r.jsx)(n.code,{children:"settings.json"})," 文件中的 ",(0,r.jsx)(n.code,{children:"mcpServers"})," 配置来定位和连接到 MCP 服务器。此配置支持具有不同传输机制的多个服务器。"]}),"\n",(0,r.jsxs)(n.h3,{id:"在-settingsjson-中配置-mcp-服务器",children:["在 settings.json 中配置 MCP 服务器",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#在-settingsjson-中配置-mcp-服务器",children:"#"})]}),"\n",(0,r.jsxs)(n.p,{children:["您可以在 ",(0,r.jsx)(n.code,{children:"settings.json"})," 文件中以两种主要方式配置 MCP 服务器：通过顶层 ",(0,r.jsx)(n.code,{children:"mcpServers"})," 对象进行特定服务器定义，以及通过 ",(0,r.jsx)(n.code,{children:"mcp"})," 对象进行控制服务器发现和执行的全局设置。"]}),"\n",(0,r.jsxs)(n.h4,{id:"全局-mcp-设置-mcp",children:["全局 MCP 设置 (",(0,r.jsx)(n.code,{children:"mcp"}),")",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#全局-mcp-设置-mcp",children:"#"})]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"settings.json"})," 中的 ",(0,r.jsx)(n.code,{children:"mcp"})," 对象允许您为所有 MCP 服务器定义全局规则。"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:(0,r.jsx)(n.code,{children:"mcp.serverCommand"})})," (字符串): 启动 MCP 服务器的全局命令。"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:(0,r.jsx)(n.code,{children:"mcp.allowed"})})," (字符串数组): 要允许的 MCP 服务器名称列表。如果设置了此项，则只会连接到此列表中的服务器（与 ",(0,r.jsx)(n.code,{children:"mcpServers"})," 对象中的键匹配）。"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:(0,r.jsx)(n.code,{children:"mcp.excluded"})})," (字符串数组): 要排除的 MCP 服务器名称列表。此列表中的服务器将不会被连接。"]}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"示例："})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-json",children:'{\n  "mcp": {\n    "allowed": ["my-trusted-server"],\n    "excluded": ["experimental-server"]\n  }\n}\n'})}),"\n",(0,r.jsxs)(n.h4,{id:"服务器特定配置-mcpservers",children:["服务器特定配置 (",(0,r.jsx)(n.code,{children:"mcpServers"}),")",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#服务器特定配置-mcpservers",children:"#"})]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"mcpServers"})," 对象是您定义希望 CLI 连接的每个单独 MCP 服务器的地方。"]}),"\n",(0,r.jsxs)(n.h3,{id:"配置结构",children:["配置结构",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#配置结构",children:"#"})]}),"\n",(0,r.jsxs)(n.p,{children:["将 ",(0,r.jsx)(n.code,{children:"mcpServers"})," 对象添加到您的 ",(0,r.jsx)(n.code,{children:"settings.json"})," 文件中："]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-json",children:'{ ...文件包含其他配置对象\n  "mcpServers": {\n    "serverName": {\n      "command": "path/to/server",\n      "args": ["--arg1", "value1"],\n      "env": {\n        "API_KEY": "$MY_API_TOKEN"\n      },\n      "cwd": "./server-directory",\n      "timeout": 30000,\n      "trust": false\n    }\n  }\n}\n'})}),"\n",(0,r.jsxs)(n.h3,{id:"配置属性",children:["配置属性",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#配置属性",children:"#"})]}),"\n",(0,r.jsx)(n.p,{children:"每个服务器配置支持以下属性："}),"\n",(0,r.jsxs)(n.h4,{id:"必需以下之一",children:["必需（以下之一）",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#必需以下之一",children:"#"})]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:(0,r.jsx)(n.code,{children:"command"})})," (字符串): Stdio 传输的可执行文件路径"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:(0,r.jsx)(n.code,{children:"url"})})," (字符串): SSE 端点 URL（例如，",(0,r.jsx)(n.code,{children:'"http://localhost:8080/sse"'}),"）"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:(0,r.jsx)(n.code,{children:"httpUrl"})})," (字符串): HTTP 流端点 URL"]}),"\n"]}),"\n",(0,r.jsxs)(n.h4,{id:"可选",children:["可选",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#可选",children:"#"})]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:(0,r.jsx)(n.code,{children:"args"})})," (字符串[]): Stdio 传输的命令行参数"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:(0,r.jsx)(n.code,{children:"headers"})})," (对象): 使用 ",(0,r.jsx)(n.code,{children:"url"})," 或 ",(0,r.jsx)(n.code,{children:"httpUrl"})," 时的自定义 HTTP 标头"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:(0,r.jsx)(n.code,{children:"env"})})," (对象): 服务器进程的环境变量。值可以使用 ",(0,r.jsx)(n.code,{children:"$VAR_NAME"})," 或 ",(0,r.jsx)(n.code,{children:"${VAR_NAME}"})," 语法引用环境变量"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:(0,r.jsx)(n.code,{children:"cwd"})})," (字符串): Stdio 传输的工作目录"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:(0,r.jsx)(n.code,{children:"timeout"})})," (数字): 请求超时时间（毫秒）（默认值：600,000ms = 10 分钟）"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:(0,r.jsx)(n.code,{children:"trust"})})," (布尔值): 当为 ",(0,r.jsx)(n.code,{children:"true"})," 时，绕过此服务器的所有工具调用确认（默认值：",(0,r.jsx)(n.code,{children:"false"}),"）"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:(0,r.jsx)(n.code,{children:"includeTools"})})," (字符串[]): 要从此 MCP 服务器包含的工具名称列表。指定时，仅此处列出的工具将从此服务器可用（允许列表行为）。如果未指定，则默认启用服务器中的所有工具。"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:(0,r.jsx)(n.code,{children:"excludeTools"})})," (字符串[]): 要从此 MCP 服务器排除的工具名称列表。此处列出的工具将不可用于模型，即使服务器公开了它们。",(0,r.jsx)(n.strong,{children:"注意："})," ",(0,r.jsx)(n.code,{children:"excludeTools"})," 优先于 ",(0,r.jsx)(n.code,{children:"includeTools"})," - 如果一个工具在两个列表中，则会被排除。"]}),"\n"]}),"\n",(0,r.jsxs)(n.h3,{id:"远程-mcp-服务器的-oauth-支持",children:["远程 MCP 服务器的 OAuth 支持",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#远程-mcp-服务器的-oauth-支持",children:"#"})]}),"\n",(0,r.jsx)(n.p,{children:"VeCLI 支持使用 SSE 或 HTTP 传输对需要身份验证的远程 MCP 服务器进行 OAuth 2.0 身份验证。这可以安全地访问需要身份验证的 MCP 服务器。"}),"\n",(0,r.jsxs)(n.h4,{id:"自动-oauth-发现",children:["自动 OAuth 发现",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#自动-oauth-发现",children:"#"})]}),"\n",(0,r.jsx)(n.p,{children:"对于支持 OAuth 发现的服务器，您可以省略 OAuth 配置，让 CLI 自动发现它："}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-json",children:'{\n  "mcpServers": {\n    "discoveredServer": {\n      "url": "https://api.example.com/sse"\n    }\n  }\n}\n'})}),"\n",(0,r.jsx)(n.p,{children:"CLI 将自动："}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"检测服务器何时需要 OAuth 身份验证（401 响应）"}),"\n",(0,r.jsx)(n.li,{children:"从服务器元数据发现 OAuth 端点"}),"\n",(0,r.jsx)(n.li,{children:"如果支持，执行动态客户端注册"}),"\n",(0,r.jsx)(n.li,{children:"处理 OAuth 流和令牌管理"}),"\n"]}),"\n",(0,r.jsxs)(n.h4,{id:"身份验证流",children:["身份验证流",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#身份验证流",children:"#"})]}),"\n",(0,r.jsx)(n.p,{children:"连接到启用了 OAuth 的服务器时："}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"初始连接尝试"})," 失败，返回 401 未授权"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"OAuth 发现"})," 找到授权和令牌端点"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"浏览器打开"})," 用于用户身份验证（需要本地浏览器访问）"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"授权码"})," 兑换为访问令牌"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"令牌安全存储"})," 以供将来使用"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"连接重试"})," 使用有效令牌成功"]}),"\n"]}),"\n",(0,r.jsxs)(n.h4,{id:"浏览器重定向要求",children:["浏览器重定向要求",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#浏览器重定向要求",children:"#"})]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"重要："})," OAuth 身份验证要求您的本地机器能够："]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"打开 Web 浏览器进行身份验证"}),"\n",(0,r.jsxs)(n.li,{children:["在 ",(0,r.jsx)(n.code,{children:"http://localhost:7777/oauth/callback"})," 上接收重定向"]}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"此功能在以下环境中无法工作："}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"没有浏览器访问权限的无头环境"}),"\n",(0,r.jsx)(n.li,{children:"没有 X11 转发的远程 SSH 会话"}),"\n",(0,r.jsx)(n.li,{children:"没有浏览器支持的容器化环境"}),"\n"]}),"\n",(0,r.jsxs)(n.h4,{id:"管理-oauth-身份验证",children:["管理 OAuth 身份验证",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#管理-oauth-身份验证",children:"#"})]}),"\n",(0,r.jsxs)(n.p,{children:["使用 ",(0,r.jsx)(n.code,{children:"/mcp auth"})," 命令管理 OAuth 身份验证："]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-bash",children:"# 列出需要身份验证的服务器\n/mcp auth\n\n# 使用特定服务器进行身份验证\n/mcp auth serverName\n\n# 如果令牌过期则重新进行身份验证\n/mcp auth serverName\n"})}),"\n",(0,r.jsxs)(n.h4,{id:"oauth-配置属性",children:["OAuth 配置属性",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#oauth-配置属性",children:"#"})]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:(0,r.jsx)(n.code,{children:"enabled"})})," (布尔值): 为此服务器启用 OAuth"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:(0,r.jsx)(n.code,{children:"clientId"})})," (字符串): OAuth 客户端标识符（可选，使用动态注册时）"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:(0,r.jsx)(n.code,{children:"clientSecret"})})," (字符串): OAuth 客户端密钥（可选，用于公共客户端）"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:(0,r.jsx)(n.code,{children:"authorizationUrl"})})," (字符串): OAuth 授权端点（如果省略则自动发现）"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:(0,r.jsx)(n.code,{children:"tokenUrl"})})," (字符串): OAuth 令牌端点（如果省略则自动发现）"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:(0,r.jsx)(n.code,{children:"scopes"})})," (字符串[]): 所需的 OAuth 范围"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:(0,r.jsx)(n.code,{children:"redirectUri"})})," (字符串): 自定义重定向 URI（默认为 ",(0,r.jsx)(n.code,{children:"http://localhost:7777/oauth/callback"}),"）"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:(0,r.jsx)(n.code,{children:"tokenParamName"})})," (字符串): SSE URL 中令牌的查询参数名称"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:(0,r.jsx)(n.code,{children:"audiences"})})," (字符串[]): 令牌有效的受众"]}),"\n"]}),"\n",(0,r.jsxs)(n.h4,{id:"令牌管理",children:["令牌管理",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#令牌管理",children:"#"})]}),"\n",(0,r.jsx)(n.p,{children:"OAuth 令牌会自动："}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"安全存储"})," 在 ",(0,r.jsx)(n.code,{children:"~/.ve/mcp-oauth-tokens.json"})," 中"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"刷新"})," 当过期时（如果有刷新令牌可用）"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"验证"})," 在每次连接尝试之前"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"清理"})," 当无效或过期时"]}),"\n"]}),"\n",(0,r.jsxs)(n.h4,{id:"身份验证提供者类型",children:["身份验证提供者类型",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#身份验证提供者类型",children:"#"})]}),"\n",(0,r.jsxs)(n.p,{children:["您可以使用 ",(0,r.jsx)(n.code,{children:"authProviderType"})," 属性指定身份验证提供者类型："]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:(0,r.jsx)(n.code,{children:"authProviderType"})})," (字符串): 指定身份验证提供者。可以是以下之一：","\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:(0,r.jsx)(n.code,{children:"dynamic_discovery"})})," (默认): CLI 将自动从服务器发现 OAuth 配置。"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:(0,r.jsx)(n.code,{children:"volcengine_credentials"})}),": CLI 将使用 Volcengine 应用默认凭据 (ADC) 对服务器进行身份验证。使用此提供者时，您必须指定所需的范围。"]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-json",children:'{\n  "mcpServers": {\n    "volcengineServer": {\n      "httpUrl": "https://my-gcp-service.run.app/mcp",\n      "authProviderType": "volcengine_credentials",\n      "oauth": {\n        "scopes": ["https://www.volcengineapis.com/auth/userinfo.email"]\n      }\n    }\n  }\n}\n'})}),"\n",(0,r.jsxs)(n.h3,{id:"示例配置",children:["示例配置",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#示例配置",children:"#"})]}),"\n",(0,r.jsxs)(n.h4,{id:"python-mcp-服务器-stdio",children:["Python MCP 服务器 (Stdio)",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#python-mcp-服务器-stdio",children:"#"})]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-json",children:'{\n  "mcpServers": {\n    "pythonTools": {\n      "command": "python",\n      "args": ["-m", "my_mcp_server", "--port", "8080"],\n      "cwd": "./mcp-servers/python",\n      "env": {\n        "DATABASE_URL": "$DB_CONNECTION_STRING",\n        "API_KEY": "${EXTERNAL_API_KEY}"\n      },\n      "timeout": 15000\n    }\n  }\n}\n'})}),"\n",(0,r.jsxs)(n.h4,{id:"nodejs-mcp-服务器-stdio",children:["Node.js MCP 服务器 (Stdio)",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#nodejs-mcp-服务器-stdio",children:"#"})]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-json",children:'{\n  "mcpServers": {\n    "nodeServer": {\n      "command": "node",\n      "args": ["dist/server.js", "--verbose"],\n      "cwd": "./mcp-servers/node",\n      "trust": true\n    }\n  }\n}\n'})}),"\n",(0,r.jsxs)(n.h4,{id:"基于-docker-的-mcp-服务器",children:["基于 Docker 的 MCP 服务器",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#基于-docker-的-mcp-服务器",children:"#"})]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-json",children:'{\n  "mcpServers": {\n    "dockerizedServer": {\n      "command": "docker",\n      "args": [\n        "run",\n        "-i",\n        "--rm",\n        "-e",\n        "API_KEY",\n        "-v",\n        "${PWD}:/workspace",\n        "my-mcp-server:latest"\n      ],\n      "env": {\n        "API_KEY": "$EXTERNAL_SERVICE_TOKEN"\n      }\n    }\n  }\n}\n'})}),"\n",(0,r.jsxs)(n.h4,{id:"基于-http-的-mcp-服务器",children:["基于 HTTP 的 MCP 服务器",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#基于-http-的-mcp-服务器",children:"#"})]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-json",children:'{\n  "mcpServers": {\n    "httpServer": {\n      "httpUrl": "http://localhost:3000/mcp",\n      "timeout": 5000\n    }\n  }\n}\n'})}),"\n",(0,r.jsxs)(n.h4,{id:"带有自定义标头的基于-http-的-mcp-服务器",children:["带有自定义标头的基于 HTTP 的 MCP 服务器",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#带有自定义标头的基于-http-的-mcp-服务器",children:"#"})]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-json",children:'{\n  "mcpServers": {\n    "httpServerWithAuth": {\n      "httpUrl": "http://localhost:3000/mcp",\n      "headers": {\n        "Authorization": "Bearer your-api-token",\n        "X-Custom-Header": "custom-value",\n        "Content-Type": "application/json"\n      },\n      "timeout": 5000\n    }\n  }\n}\n'})}),"\n",(0,r.jsxs)(n.h4,{id:"带有工具过滤的-mcp-服务器",children:["带有工具过滤的 MCP 服务器",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#带有工具过滤的-mcp-服务器",children:"#"})]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-json",children:'{\n  "mcpServers": {\n    "filteredServer": {\n      "command": "python",\n      "args": ["-m", "my_mcp_server"],\n      "includeTools": ["safe_tool", "file_reader", "data_processor"],\n      // "excludeTools": ["dangerous_tool", "file_deleter"],\n      "timeout": 30000\n    }\n  }\n}\n'})}),"\n",(0,r.jsxs)(n.h2,{id:"发现阶段深入",children:["发现阶段深入",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#发现阶段深入",children:"#"})]}),"\n",(0,r.jsx)(n.p,{children:"当 VeCLI 启动时，它通过以下详细过程执行 MCP 服务器发现："}),"\n",(0,r.jsxs)(n.h3,{id:"1-服务器迭代和连接",children:["1. 服务器迭代和连接",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#1-服务器迭代和连接",children:"#"})]}),"\n",(0,r.jsxs)(n.p,{children:["对于 ",(0,r.jsx)(n.code,{children:"mcpServers"})," 中配置的每个服务器："]}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"状态跟踪开始："})," 服务器状态设置为 ",(0,r.jsx)(n.code,{children:"CONNECTING"})]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"传输选择："})," 基于配置属性：","\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"httpUrl"})," → ",(0,r.jsx)(n.code,{children:"StreamableHTTPClientTransport"})]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"url"})," → ",(0,r.jsx)(n.code,{children:"SSEClientTransport"})]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"command"})," → ",(0,r.jsx)(n.code,{children:"StdioClientTransport"})]}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"连接建立："})," MCP 客户端尝试使用配置的超时连接"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"错误处理："})," 连接失败会被记录，服务器状态设置为 ",(0,r.jsx)(n.code,{children:"DISCONNECTED"})]}),"\n"]}),"\n",(0,r.jsxs)(n.h3,{id:"2-工具发现",children:["2. 工具发现",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#2-工具发现",children:"#"})]}),"\n",(0,r.jsx)(n.p,{children:"连接成功后："}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"工具列表："})," 客户端调用 MCP 服务器的工具列表端点"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"模式验证："})," 验证每个工具的函数声明"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"工具过滤："})," 根据 ",(0,r.jsx)(n.code,{children:"includeTools"})," 和 ",(0,r.jsx)(n.code,{children:"excludeTools"})," 配置过滤工具"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"名称清理："})," 工具名称被清理以满足 Vecli API 要求：","\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"无效字符（非字母数字、下划线、点、连字符）被替换为下划线"}),"\n",(0,r.jsxs)(n.li,{children:["超过 63 个字符的名称会被截断，并用中间替换 (",(0,r.jsx)(n.code,{children:"___"}),")"]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.h3,{id:"3-冲突解决",children:["3. 冲突解决",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#3-冲突解决",children:"#"})]}),"\n",(0,r.jsx)(n.p,{children:"当多个服务器公开同名工具时："}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"首次注册获胜："})," 第一个注册工具名称的服务器获得未加前缀的名称"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"自动加前缀："})," 后续服务器获得加前缀的名称：",(0,r.jsx)(n.code,{children:"serverName__toolName"})]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"注册表跟踪："})," 工具注册表维护服务器名称与其工具之间的映射"]}),"\n"]}),"\n",(0,r.jsxs)(n.h3,{id:"4-模式处理",children:["4. 模式处理",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#4-模式处理",children:"#"})]}),"\n",(0,r.jsx)(n.p,{children:"工具参数模式经过清理以确保与 Vecli API 兼容："}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsxs)(n.strong,{children:[(0,r.jsx)(n.code,{children:"$schema"})," 属性"]})," 被移除"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:(0,r.jsx)(n.code,{children:"additionalProperties"})})," 被剥离"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsxs)(n.strong,{children:["带有 ",(0,r.jsx)(n.code,{children:"default"})," 的 ",(0,r.jsx)(n.code,{children:"anyOf"})]})," 其默认值被移除（Vertex AI 兼容性）"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"递归处理"})," 应用于嵌套模式"]}),"\n"]}),"\n",(0,r.jsxs)(n.h3,{id:"5-连接管理",children:["5. 连接管理",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#5-连接管理",children:"#"})]}),"\n",(0,r.jsx)(n.p,{children:"发现后："}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"持久连接："})," 成功注册工具的服务器保持其连接"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"清理："})," 不提供可用工具的服务器的连接会被关闭"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"状态更新："})," 最终服务器状态设置为 ",(0,r.jsx)(n.code,{children:"CONNECTED"})," 或 ",(0,r.jsx)(n.code,{children:"DISCONNECTED"})]}),"\n"]}),"\n",(0,r.jsxs)(n.h2,{id:"工具执行流程",children:["工具执行流程",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#工具执行流程",children:"#"})]}),"\n",(0,r.jsx)(n.p,{children:"当 Vecli 模型决定使用 MCP 工具时，会发生以下执行流程："}),"\n",(0,r.jsxs)(n.h3,{id:"1-工具调用",children:["1. 工具调用",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#1-工具调用",children:"#"})]}),"\n",(0,r.jsxs)(n.p,{children:["模型生成一个 ",(0,r.jsx)(n.code,{children:"FunctionCall"}),"，其中包含："]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"工具名称："})," 注册的名称（可能加了前缀）"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"参数："})," 与工具参数模式匹配的 JSON 对象"]}),"\n"]}),"\n",(0,r.jsxs)(n.h3,{id:"2-确认过程",children:["2. 确认过程",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#2-确认过程",children:"#"})]}),"\n",(0,r.jsxs)(n.p,{children:["每个 ",(0,r.jsx)(n.code,{children:"DiscoveredMCPTool"})," 实现了复杂的确认逻辑："]}),"\n",(0,r.jsxs)(n.h4,{id:"基于信任的绕过",children:["基于信任的绕过",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#基于信任的绕过",children:"#"})]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"if (this.trust) {\n  return false; // 无需确认\n}\n"})}),"\n",(0,r.jsxs)(n.h4,{id:"动态允许列表",children:["动态允许列表",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#动态允许列表",children:"#"})]}),"\n",(0,r.jsx)(n.p,{children:"系统为以下内容维护内部允许列表："}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"服务器级别："})," ",(0,r.jsx)(n.code,{children:"serverName"})," → 来自此服务器的所有工具都被信任"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"工具级别："})," ",(0,r.jsx)(n.code,{children:"serverName.toolName"})," → 此特定工具被信任"]}),"\n"]}),"\n",(0,r.jsxs)(n.h4,{id:"用户选择处理",children:["用户选择处理",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#用户选择处理",children:"#"})]}),"\n",(0,r.jsx)(n.p,{children:"需要确认时，用户可以选择："}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"仅此一次："})," 仅执行这一次"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"始终允许此工具："})," 添加到工具级别允许列表"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"始终允许此服务器："})," 添加到服务器级别允许列表"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"取消："})," 中止执行"]}),"\n"]}),"\n",(0,r.jsxs)(n.h3,{id:"3-执行",children:["3. 执行",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#3-执行",children:"#"})]}),"\n",(0,r.jsx)(n.p,{children:"确认后（或信任绕过）："}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"参数准备："})," 参数根据工具的模式进行验证"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"MCP 调用："})," 底层 ",(0,r.jsx)(n.code,{children:"CallableTool"})," 使用以下内容调用服务器："]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"const functionCalls = [\n  {\n    name: this.serverToolName, // 原始服务器工具名称\n    args: params,\n  },\n];\n"})}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"响应处理："})," 结果被格式化为 LLM 上下文和用户显示"]}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.h3,{id:"4-响应处理",children:["4. 响应处理",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#4-响应处理",children:"#"})]}),"\n",(0,r.jsx)(n.p,{children:"执行结果包含："}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsxs)(n.strong,{children:[(0,r.jsx)(n.code,{children:"llmContent"}),"："]})," 用于语言模型上下文的原始响应部分"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsxs)(n.strong,{children:[(0,r.jsx)(n.code,{children:"returnDisplay"}),"："]})," 用于用户显示的格式化输出（通常是 JSON 格式的代码块）"]}),"\n"]}),"\n",(0,r.jsxs)(n.h2,{id:"如何与您的-mcp-服务器交互",children:["如何与您的 MCP 服务器交互",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#如何与您的-mcp-服务器交互",children:"#"})]}),"\n",(0,r.jsxs)(n.h3,{id:"使用-mcp-命令",children:["使用 ",(0,r.jsx)(n.code,{children:"/mcp"})," 命令",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#使用-mcp-命令",children:"#"})]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"/mcp"})," 命令提供有关 MCP 服务器设置的全面信息："]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-bash",children:"/mcp\n"})}),"\n",(0,r.jsx)(n.p,{children:"这将显示："}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"服务器列表："})," 所有配置的 MCP 服务器"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"连接状态："})," ",(0,r.jsx)(n.code,{children:"CONNECTED"}),"、",(0,r.jsx)(n.code,{children:"CONNECTING"})," 或 ",(0,r.jsx)(n.code,{children:"DISCONNECTED"})]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"服务器详细信息："})," 配置摘要（不包括敏感数据）"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"可用工具："})," 每个服务器的工具列表及其描述"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"发现状态："})," 整体发现过程状态"]}),"\n"]}),"\n",(0,r.jsxs)(n.h3,{id:"示例-mcp-输出",children:["示例 ",(0,r.jsx)(n.code,{children:"/mcp"})," 输出",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#示例-mcp-输出",children:"#"})]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"MCP 服务器状态:\n\n\uD83D\uDCE1 pythonTools (已连接)\n  命令: python -m my_mcp_server --port 8080\n  工作目录: ./mcp-servers/python\n  超时: 15000ms\n  工具: calculate_sum, file_analyzer, data_processor\n\n\uD83D\uDD0C nodeServer (已断开)\n  命令: node dist/server.js --verbose\n  错误: 连接被拒绝\n\n\uD83D\uDC33 dockerizedServer (已连接)\n  命令: docker run -i --rm -e API_KEY my-mcp-server:latest\n  工具: docker__deploy, docker__status\n\n发现状态: 已完成\n"})}),"\n",(0,r.jsxs)(n.h3,{id:"工具使用",children:["工具使用",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#工具使用",children:"#"})]}),"\n",(0,r.jsx)(n.p,{children:"发现后，MCP 工具对 Vecli 模型来说就像内置工具一样可用。模型将自动："}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"选择合适的工具"})," 基于您的请求"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"显示确认对话框"})," （除非服务器受信任）"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"执行工具"})," 使用正确的参数"]}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.strong,{children:"以用户友好的格式显示结果"})}),"\n"]}),"\n",(0,r.jsxs)(n.h2,{id:"状态监控和故障排除",children:["状态监控和故障排除",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#状态监控和故障排除",children:"#"})]}),"\n",(0,r.jsxs)(n.h3,{id:"连接状态",children:["连接状态",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#连接状态",children:"#"})]}),"\n",(0,r.jsx)(n.p,{children:"MCP 集成跟踪几种状态："}),"\n",(0,r.jsxs)(n.h4,{id:"服务器状态-mcpserverstatus",children:["服务器状态 (",(0,r.jsx)(n.code,{children:"MCPServerStatus"}),")",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#服务器状态-mcpserverstatus",children:"#"})]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsxs)(n.strong,{children:[(0,r.jsx)(n.code,{children:"DISCONNECTED"}),":"]})," 服务器未连接或有错误"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsxs)(n.strong,{children:[(0,r.jsx)(n.code,{children:"CONNECTING"}),":"]})," 正在进行连接尝试"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsxs)(n.strong,{children:[(0,r.jsx)(n.code,{children:"CONNECTED"}),":"]})," 服务器已连接并准备就绪"]}),"\n"]}),"\n",(0,r.jsxs)(n.h4,{id:"发现状态-mcpdiscoverystate",children:["发现状态 (",(0,r.jsx)(n.code,{children:"MCPDiscoveryState"}),")",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#发现状态-mcpdiscoverystate",children:"#"})]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsxs)(n.strong,{children:[(0,r.jsx)(n.code,{children:"NOT_STARTED"}),":"]})," 发现尚未开始"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsxs)(n.strong,{children:[(0,r.jsx)(n.code,{children:"IN_PROGRESS"}),":"]})," 当前正在发现服务器"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsxs)(n.strong,{children:[(0,r.jsx)(n.code,{children:"COMPLETED"}),":"]})," 发现已完成（有或没有错误）"]}),"\n"]}),"\n",(0,r.jsxs)(n.h3,{id:"常见问题和解决方案",children:["常见问题和解决方案",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#常见问题和解决方案",children:"#"})]}),"\n",(0,r.jsxs)(n.h4,{id:"服务器无法连接",children:["服务器无法连接",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#服务器无法连接",children:"#"})]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"症状："})," 服务器显示 ",(0,r.jsx)(n.code,{children:"DISCONNECTED"})," 状态"]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"故障排除："})}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"检查配置："})," 验证 ",(0,r.jsx)(n.code,{children:"command"}),"、",(0,r.jsx)(n.code,{children:"args"})," 和 ",(0,r.jsx)(n.code,{children:"cwd"})," 是否正确"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"手动测试："})," 直接运行服务器命令以确保其正常工作"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"检查依赖项："})," 确保所有必需的包都已安装"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"查看日志："})," 在 CLI 输出中查找错误消息"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"验证权限："})," 确保 CLI 可以执行服务器命令"]}),"\n"]}),"\n",(0,r.jsxs)(n.h4,{id:"未发现工具",children:["未发现工具",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#未发现工具",children:"#"})]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"症状："})," 服务器连接但没有可用的工具"]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"故障排除："})}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"验证工具注册："})," 确保您的服务器实际注册了工具"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"检查 MCP 协议："})," 确认您的服务器正确实现了 MCP 工具列表"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"查看服务器日志："})," 检查 stderr 输出以查找服务器端错误"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"测试工具列表："})," 手动测试服务器的工具发现端点"]}),"\n"]}),"\n",(0,r.jsxs)(n.h4,{id:"工具无法执行",children:["工具无法执行",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#工具无法执行",children:"#"})]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"症状："})," 工具被发现但在执行期间失败"]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"故障排除："})}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"参数验证："})," 确保您的工具接受预期的参数"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"模式兼容性："})," 验证您的输入模式是有效的 JSON 模式"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"错误处理："})," 检查您的工具是否抛出未处理的异常"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"超时问题："})," 考虑增加 ",(0,r.jsx)(n.code,{children:"timeout"})," 设置"]}),"\n"]}),"\n",(0,r.jsxs)(n.h4,{id:"沙盒兼容性",children:["沙盒兼容性",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#沙盒兼容性",children:"#"})]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"症状："})," 启用沙盒时 MCP 服务器失败"]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"解决方案："})}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"基于 Docker 的服务器："})," 使用包含所有依赖项的 Docker 容器"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"路径可访问性："})," 确保沙盒环境中可以访问服务器可执行文件"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"网络访问："})," 配置沙盒以允许必要的网络连接"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"环境变量："})," 验证所需的环境变量是否已传递"]}),"\n"]}),"\n",(0,r.jsxs)(n.h3,{id:"调试技巧",children:["调试技巧",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#调试技巧",children:"#"})]}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"启用调试模式："})," 使用 ",(0,r.jsx)(n.code,{children:"--debug"})," 运行 CLI 以获取详细输出"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"检查 stderr："})," MCP 服务器 stderr 被捕获并记录（INFO 消息被过滤）"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"测试隔离："})," 在集成之前独立测试您的 MCP 服务器"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"增量设置："})," 在添加复杂功能之前从简单工具开始"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsxs)(n.strong,{children:["频繁使用 ",(0,r.jsx)(n.code,{children:"/mcp"}),"："]})," 在开发过程中监控服务器状态"]}),"\n"]}),"\n",(0,r.jsxs)(n.h2,{id:"重要说明",children:["重要说明",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#重要说明",children:"#"})]}),"\n",(0,r.jsxs)(n.h3,{id:"安全注意事项",children:["安全注意事项",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#安全注意事项",children:"#"})]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"信任设置："})," ",(0,r.jsx)(n.code,{children:"trust"})," 选项绕过所有确认对话框。请谨慎使用，仅用于您完全控制的服务器"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"访问令牌："})," 配置包含 API 密钥或令牌的环境变量时要注意安全"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"沙盒兼容性："})," 使用沙盒时，确保 MCP 服务器在沙盒环境中可用"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"私人数据："})," 使用范围广泛的个人访问令牌可能导致存储库之间的信息泄露"]}),"\n"]}),"\n",(0,r.jsxs)(n.h3,{id:"性能和资源管理",children:["性能和资源管理",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#性能和资源管理",children:"#"})]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"连接持久性："})," CLI 保持与成功注册工具的服务器的持久连接"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"自动清理："})," 到不提供工具的服务器的连接会自动关闭"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"超时管理："})," 根据服务器的响应特性配置适当的超时"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"资源监控："})," MCP 服务器作为单独的进程运行并消耗系统资源"]}),"\n"]}),"\n",(0,r.jsxs)(n.h3,{id:"模式兼容性",children:["模式兼容性",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#模式兼容性",children:"#"})]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"属性剥离："})," 系统会自动移除某些模式属性（",(0,r.jsx)(n.code,{children:"$schema"}),"、",(0,r.jsx)(n.code,{children:"additionalProperties"}),"）以确保与 Vecli API 兼容"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"名称清理："})," 工具名称会自动清理以满足 API 要求"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"冲突解决："})," 服务器之间的工具名称冲突通过自动加前缀解决"]}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"这种全面的集成使 MCP 服务器成为扩展 VeCLI 功能的强大方式，同时保持安全性、可靠性和易用性。"}),"\n",(0,r.jsxs)(n.h2,{id:"从工具返回富内容",children:["从工具返回富内容",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#从工具返回富内容",children:"#"})]}),"\n",(0,r.jsx)(n.p,{children:"MCP 工具不仅限于返回简单文本。您可以返回富多部分内容，包括文本、图像、音频和其他二进制数据，作为单个工具响应。这使您能够构建强大的工具，可以在单个回合中向模型提供多样化的信息。"}),"\n",(0,r.jsx)(n.p,{children:"所有从工具返回的数据都会被处理并作为上下文发送给模型，以供其下一次生成使用，使其能够推理或总结提供的信息。"}),"\n",(0,r.jsxs)(n.h3,{id:"工作原理",children:["工作原理",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#工作原理",children:"#"})]}),"\n",(0,r.jsxs)(n.p,{children:["要返回富内容，您的工具响应必须遵循 MCP 规范中的 ",(0,r.jsx)(n.a,{href:"https://modelcontextprotocol.io/specification/2025-06-18/server/tools#tool-result",target:"_blank",rel:"noopener noreferrer",children:(0,r.jsx)(n.code,{children:"CallToolResult"})}),"。结果的 ",(0,r.jsx)(n.code,{children:"content"})," 字段应该是一个 ",(0,r.jsx)(n.code,{children:"ContentBlock"})," 对象数组。VeCLI 将正确处理此数组，将文本与二进制数据分离并打包给模型。"]}),"\n",(0,r.jsxs)(n.p,{children:["您可以在 ",(0,r.jsx)(n.code,{children:"content"})," 数组中混合和匹配不同的内容块类型。支持的块类型包括："]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.code,{children:"text"})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.code,{children:"image"})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.code,{children:"audio"})}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"resource"})," (嵌入内容)"]}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.code,{children:"resource_link"})}),"\n"]}),"\n",(0,r.jsxs)(n.h3,{id:"示例返回文本和图像",children:["示例：返回文本和图像",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#示例返回文本和图像",children:"#"})]}),"\n",(0,r.jsx)(n.p,{children:"以下是一个有效的 MCP 工具 JSON 响应示例，该响应同时返回文本描述和图像："}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-json",children:'{\n  "content": [\n    {\n      "type": "text",\n      "text": "这是您请求的徽标。"\n    },\n    {\n      "type": "image",\n      "data": "BASE64_ENCODED_IMAGE_DATA_HERE",\n      "mimeType": "image/png"\n    },\n    {\n      "type": "text",\n      "text": "徽标于 2025 年创建。"\n    }\n  ]\n}\n'})}),"\n",(0,r.jsx)(n.p,{children:"当 VeCLI 收到此响应时，它将："}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:["提取所有文本并将其组合成一个 ",(0,r.jsx)(n.code,{children:"functionResponse"})," 部分供模型使用。"]}),"\n",(0,r.jsxs)(n.li,{children:["将图像数据作为单独的 ",(0,r.jsx)(n.code,{children:"inlineData"})," 部分呈现。"]}),"\n",(0,r.jsx)(n.li,{children:"在 CLI 中提供一个干净、用户友好的摘要，表明已收到文本和图像。"}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"这使您能够构建复杂的工具，向 Vecli 模型提供丰富的多模态上下文。"}),"\n",(0,r.jsxs)(n.h2,{id:"作为斜杠命令的-mcp-提示",children:["作为斜杠命令的 MCP 提示",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#作为斜杠命令的-mcp-提示",children:"#"})]}),"\n",(0,r.jsx)(n.p,{children:"除了工具，MCP 服务器还可以公开预定义的提示，这些提示可以在 VeCLI 中作为斜杠命令执行。这使您能够为常见或复杂的查询创建快捷方式，可以通过名称轻松调用。"}),"\n",(0,r.jsxs)(n.h3,{id:"在服务器上定义提示",children:["在服务器上定义提示",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#在服务器上定义提示",children:"#"})]}),"\n",(0,r.jsx)(n.p,{children:"以下是一个定义提示的小型 stdio MCP 服务器示例："}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"import { McpServer } from '@modelcontextprotocol/sdk/server/mcp.js';\nimport { StdioServerTransport } from '@modelcontextprotocol/sdk/server/stdio.js';\nimport { z } from 'zod';\n\nconst server = new McpServer({\n  name: 'prompt-server',\n  version: '1.0.0',\n});\n\nserver.registerPrompt(\n  'poem-writer',\n  {\n    title: '诗歌作家',\n    description: '写一首优美的俳句',\n    argsSchema: { title: z.string(), mood: z.string().optional() },\n  },\n  ({ title, mood }) => ({\n    messages: [\n      {\n        role: 'user',\n        content: {\n          type: 'text',\n          text: `写一首俳句${mood ? `，情绪为 ${mood}` : ''}，标题为 ${title}。请注意，俳句是 5 个音节，然后是 7 个音节，再然后是 5 个音节 `,\n        },\n      },\n    ],\n  }),\n);\n\nconst transport = new StdioServerTransport();\nawait server.connect(transport);\n"})}),"\n",(0,r.jsxs)(n.p,{children:["这可以在 ",(0,r.jsx)(n.code,{children:"settings.json"})," 中的 ",(0,r.jsx)(n.code,{children:"mcpServers"})," 下包含："]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-json",children:'{\n  "mcpServers": {\n    "nodeServer": {\n      "command": "node",\n      "args": ["filename.ts"]\n    }\n  }\n}\n'})}),"\n",(0,r.jsxs)(n.h3,{id:"调用提示",children:["调用提示",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#调用提示",children:"#"})]}),"\n",(0,r.jsx)(n.p,{children:"发现提示后，您可以使用其名称作为斜杠命令来调用它。CLI 将自动处理参数解析。"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-bash",children:'/poem-writer --title="VeCLI" --mood="reverent"\n'})}),"\n",(0,r.jsx)(n.p,{children:"或者，使用位置参数："}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-bash",children:'/poem-writer "VeCLI" reverent\n'})}),"\n",(0,r.jsxs)(n.p,{children:["运行此命令时，VeCLI 在 MCP 服务器上执行 ",(0,r.jsx)(n.code,{children:"prompts/get"})," 方法并提供参数。服务器负责将参数代入提示模板并返回最终提示文本。CLI 然后将此提示发送给模型执行。这提供了一种方便的方式来自动化和共享常见工作流。"]}),"\n",(0,r.jsxs)(n.h2,{id:"使用-vecli-mcp-管理-mcp-服务器",children:["使用 ",(0,r.jsx)(n.code,{children:"vecli mcp"})," 管理 MCP 服务器",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#使用-vecli-mcp-管理-mcp-服务器",children:"#"})]}),"\n",(0,r.jsxs)(n.p,{children:["虽然您总是可以通过手动编辑 ",(0,r.jsx)(n.code,{children:"settings.json"})," 文件来配置 MCP 服务器，但 VeCLI 提供了一组方便的命令来以编程方式管理您的服务器配置。这些命令简化了添加、列出和删除 MCP 服务器的过程，而无需直接编辑 JSON 文件。"]}),"\n",(0,r.jsxs)(n.h3,{id:"添加服务器-vecli-mcp-add",children:["添加服务器 (",(0,r.jsx)(n.code,{children:"vecli mcp add"}),")",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#添加服务器-vecli-mcp-add",children:"#"})]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"add"})," 命令在您的 ",(0,r.jsx)(n.code,{children:"settings.json"})," 中配置一个新的 MCP 服务器。根据范围 (",(0,r.jsx)(n.code,{children:"-s, --scope"}),")，它将被添加到用户配置 ",(0,r.jsx)(n.code,{children:"~/.ve/settings.json"})," 或项目配置 ",(0,r.jsx)(n.code,{children:".ve/settings.json"})," 文件中。"]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"命令："})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-bash",children:"vecli mcp add [options] <name> <commandOrUrl> [args...]\n"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"<name>"}),": 服务器的唯一名称。"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"<commandOrUrl>"}),": 要执行的命令（用于 ",(0,r.jsx)(n.code,{children:"stdio"}),"）或 URL（用于 ",(0,r.jsx)(n.code,{children:"http"}),"/",(0,r.jsx)(n.code,{children:"sse"}),"）。"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"[args...]"}),": ",(0,r.jsx)(n.code,{children:"stdio"})," 命令的可选参数。"]}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"选项（标志）："})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"-s, --scope"}),': 配置范围（用户或项目）。[默认: "project"]']}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"-t, --transport"}),': 传输类型（stdio, sse, http）。[默认: "stdio"]']}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"-e, --env"}),": 设置环境变量（例如 -e KEY=value）。"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"-H, --header"}),': 为 SSE 和 HTTP 传输设置 HTTP 标头（例如 -H "X-Api-Key: abc123" -H "Authorization: Bearer abc123"）。']}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"--timeout"}),": 设置连接超时时间（毫秒）。"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"--trust"}),": 信任服务器（绕过所有工具调用确认提示）。"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"--description"}),": 设置服务器的描述。"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"--include-tools"}),": 以逗号分隔的要包含的工具列表。"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"--exclude-tools"}),": 以逗号分隔的要排除的工具列表。"]}),"\n"]}),"\n",(0,r.jsxs)(n.h4,{id:"添加一个-stdio-服务器",children:["添加一个 stdio 服务器",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#添加一个-stdio-服务器",children:"#"})]}),"\n",(0,r.jsx)(n.p,{children:"这是运行本地服务器的默认传输。"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-bash",children:"# 基本语法\nvecli mcp add <name> <command> [args...]\n\n# 示例: 添加一个本地服务器\nvecli mcp add my-stdio-server -e API_KEY=123 /path/to/server arg1 arg2 arg3\n\n# 示例: 添加一个本地 python 服务器\nvecli mcp add python-server python server.py --port 8080\n"})}),"\n",(0,r.jsxs)(n.h4,{id:"添加一个-http-服务器",children:["添加一个 HTTP 服务器",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#添加一个-http-服务器",children:"#"})]}),"\n",(0,r.jsx)(n.p,{children:"此传输用于使用可流式 HTTP 传输的服务器。"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-bash",children:'# 基本语法\nvecli mcp add --transport http <name> <url>\n\n# 示例: 添加一个 HTTP 服务器\nvecli mcp add --transport http http-server https://api.example.com/mcp/\n\n# 示例: 添加一个带有身份验证标头的 HTTP 服务器\nvecli mcp add --transport http secure-http https://api.example.com/mcp/ --header "Authorization: Bearer abc123"\n'})}),"\n",(0,r.jsxs)(n.h4,{id:"添加一个-sse-服务器",children:["添加一个 SSE 服务器",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#添加一个-sse-服务器",children:"#"})]}),"\n",(0,r.jsx)(n.p,{children:"此传输用于使用服务器发送事件 (SSE) 的服务器。"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-bash",children:'# 基本语法\nvecli mcp add --transport sse <name> <url>\n\n# 示例: 添加一个 SSE 服务器\nvecli mcp add --transport sse sse-server https://api.example.com/sse/\n\n# 示例: 添加一个带有身份验证标头的 SSE 服务器\nvecli mcp add --transport sse secure-sse https://api.example.com/sse/ --header "Authorization: Bearer abc123"\n'})}),"\n",(0,r.jsxs)(n.h3,{id:"列出服务器-vecli-mcp-list",children:["列出服务器 (",(0,r.jsx)(n.code,{children:"vecli mcp list"}),")",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#列出服务器-vecli-mcp-list",children:"#"})]}),"\n",(0,r.jsxs)(n.p,{children:["要查看当前配置的所有 MCP 服务器，请使用 ",(0,r.jsx)(n.code,{children:"list"})," 命令。它显示每个服务器的名称、配置详细信息和连接状态。"]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"命令："})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-bash",children:"vecli mcp list\n"})}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"示例输出："})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-sh",children:"✓ stdio-server: 命令: python3 server.py (stdio) - 已连接\n✓ http-server: https://api.example.com/mcp (http) - 已连接\n✗ sse-server: https://api.example.com/sse (sse) - 已断开\n"})}),"\n",(0,r.jsxs)(n.h3,{id:"删除服务器-vecli-mcp-remove",children:["删除服务器 (",(0,r.jsx)(n.code,{children:"vecli mcp remove"}),")",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#删除服务器-vecli-mcp-remove",children:"#"})]}),"\n",(0,r.jsxs)(n.p,{children:["要从配置中删除服务器，请使用 ",(0,r.jsx)(n.code,{children:"remove"})," 命令和服务器名称。"]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"命令："})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-bash",children:"vecli mcp remove <name>\n"})}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"示例："})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-bash",children:"vecli mcp remove my-server\n"})}),"\n",(0,r.jsxs)(n.p,{children:["这将根据范围 (",(0,r.jsx)(n.code,{children:"-s, --scope"}),") 在相应的 ",(0,r.jsx)(n.code,{children:"settings.json"})," 文件中的 ",(0,r.jsx)(n.code,{children:"mcpServers"}),' 对象中查找并删除 "my-server" 条目。']})]})}function i(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:n}=Object.assign({},(0,d.ah)(),e.components);return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(c,{...e})}):c(e)}let h=i;i.__RSPRESS_PAGE_META={},i.__RSPRESS_PAGE_META["zh%2Ftools%2Fmcp-server.md"]={toc:[{text:"什么是 MCP 服务器？",id:"什么是-mcp-服务器",depth:2},{text:"核心集成架构",id:"核心集成架构",depth:2},{text:"发现阶段 (`mcp-client.ts`)",id:"发现阶段-mcp-clientts",depth:3},{text:"执行层 (`mcp-tool.ts`)",id:"执行层-mcp-toolts",depth:3},{text:"传输机制",id:"传输机制",depth:3},{text:"如何设置您的 MCP 服务器",id:"如何设置您的-mcp-服务器",depth:2},{text:"在 settings.json 中配置 MCP 服务器",id:"在-settingsjson-中配置-mcp-服务器",depth:3},{text:"全局 MCP 设置 (`mcp`)",id:"全局-mcp-设置-mcp",depth:4},{text:"服务器特定配置 (`mcpServers`)",id:"服务器特定配置-mcpservers",depth:4},{text:"配置结构",id:"配置结构",depth:3},{text:"配置属性",id:"配置属性",depth:3},{text:"必需（以下之一）",id:"必需以下之一",depth:4},{text:"可选",id:"可选",depth:4},{text:"远程 MCP 服务器的 OAuth 支持",id:"远程-mcp-服务器的-oauth-支持",depth:3},{text:"自动 OAuth 发现",id:"自动-oauth-发现",depth:4},{text:"身份验证流",id:"身份验证流",depth:4},{text:"浏览器重定向要求",id:"浏览器重定向要求",depth:4},{text:"管理 OAuth 身份验证",id:"管理-oauth-身份验证",depth:4},{text:"OAuth 配置属性",id:"oauth-配置属性",depth:4},{text:"令牌管理",id:"令牌管理",depth:4},{text:"身份验证提供者类型",id:"身份验证提供者类型",depth:4},{text:"示例配置",id:"示例配置",depth:3},{text:"Python MCP 服务器 (Stdio)",id:"python-mcp-服务器-stdio",depth:4},{text:"Node.js MCP 服务器 (Stdio)",id:"nodejs-mcp-服务器-stdio",depth:4},{text:"基于 Docker 的 MCP 服务器",id:"基于-docker-的-mcp-服务器",depth:4},{text:"基于 HTTP 的 MCP 服务器",id:"基于-http-的-mcp-服务器",depth:4},{text:"带有自定义标头的基于 HTTP 的 MCP 服务器",id:"带有自定义标头的基于-http-的-mcp-服务器",depth:4},{text:"带有工具过滤的 MCP 服务器",id:"带有工具过滤的-mcp-服务器",depth:4},{text:"发现阶段深入",id:"发现阶段深入",depth:2},{text:"1. 服务器迭代和连接",id:"1-服务器迭代和连接",depth:3},{text:"2. 工具发现",id:"2-工具发现",depth:3},{text:"3. 冲突解决",id:"3-冲突解决",depth:3},{text:"4. 模式处理",id:"4-模式处理",depth:3},{text:"5. 连接管理",id:"5-连接管理",depth:3},{text:"工具执行流程",id:"工具执行流程",depth:2},{text:"1. 工具调用",id:"1-工具调用",depth:3},{text:"2. 确认过程",id:"2-确认过程",depth:3},{text:"基于信任的绕过",id:"基于信任的绕过",depth:4},{text:"动态允许列表",id:"动态允许列表",depth:4},{text:"用户选择处理",id:"用户选择处理",depth:4},{text:"3. 执行",id:"3-执行",depth:3},{text:"4. 响应处理",id:"4-响应处理",depth:3},{text:"如何与您的 MCP 服务器交互",id:"如何与您的-mcp-服务器交互",depth:2},{text:"使用 `/mcp` 命令",id:"使用-mcp-命令",depth:3},{text:"示例 `/mcp` 输出",id:"示例-mcp-输出",depth:3},{text:"工具使用",id:"工具使用",depth:3},{text:"状态监控和故障排除",id:"状态监控和故障排除",depth:2},{text:"连接状态",id:"连接状态",depth:3},{text:"服务器状态 (`MCPServerStatus`)",id:"服务器状态-mcpserverstatus",depth:4},{text:"发现状态 (`MCPDiscoveryState`)",id:"发现状态-mcpdiscoverystate",depth:4},{text:"常见问题和解决方案",id:"常见问题和解决方案",depth:3},{text:"服务器无法连接",id:"服务器无法连接",depth:4},{text:"未发现工具",id:"未发现工具",depth:4},{text:"工具无法执行",id:"工具无法执行",depth:4},{text:"沙盒兼容性",id:"沙盒兼容性",depth:4},{text:"调试技巧",id:"调试技巧",depth:3},{text:"重要说明",id:"重要说明",depth:2},{text:"安全注意事项",id:"安全注意事项",depth:3},{text:"性能和资源管理",id:"性能和资源管理",depth:3},{text:"模式兼容性",id:"模式兼容性",depth:3},{text:"从工具返回富内容",id:"从工具返回富内容",depth:2},{text:"工作原理",id:"工作原理",depth:3},{text:"示例：返回文本和图像",id:"示例返回文本和图像",depth:3},{text:"作为斜杠命令的 MCP 提示",id:"作为斜杠命令的-mcp-提示",depth:2},{text:"在服务器上定义提示",id:"在服务器上定义提示",depth:3},{text:"调用提示",id:"调用提示",depth:3},{text:"使用 `vecli mcp` 管理 MCP 服务器",id:"使用-vecli-mcp-管理-mcp-服务器",depth:2},{text:"添加服务器 (`vecli mcp add`)",id:"添加服务器-vecli-mcp-add",depth:3},{text:"添加一个 stdio 服务器",id:"添加一个-stdio-服务器",depth:4},{text:"添加一个 HTTP 服务器",id:"添加一个-http-服务器",depth:4},{text:"添加一个 SSE 服务器",id:"添加一个-sse-服务器",depth:4},{text:"列出服务器 (`vecli mcp list`)",id:"列出服务器-vecli-mcp-list",depth:3},{text:"删除服务器 (`vecli mcp remove`)",id:"删除服务器-vecli-mcp-remove",depth:3}],title:"使用 VeCLI 的 MCP 服务器",headingTitle:"使用 VeCLI 的 MCP 服务器",frontmatter:{}}}}]);