"use strict";(self.webpackChunklcm_test_page=self.webpackChunklcm_test_page||[]).push([["3342"],{6306:function(n,e,o){o.r(e),o.d(e,{default:()=>m});var s=o(5893),c=o(65);function l(n){let e=Object.assign({h1:"h1",code:"code",a:"a",strong:"strong"},(0,c.ah)(),n.components);return(0,s.jsxs)(e.h1,{id:"vecli-扩展nnvecli-支持可以用于配置和扩展其功能的扩展nn-工作原理nn在启动时vecli-会在两个位置查找扩展nn1--workspacevecliextensionsn2--homevecliextensionsnnvecli-从这两个位置加载所有扩展如果两个位置都存在同名扩展则工作区目录中的扩展优先nn在每个位置内单个扩展作为一个包含-vecli-extensionjson-文件的目录存在例如nnworkspacevecliextensionsmy-extensionvecli-extensionjsonnn-vecli-extensionjsonnnvecli-extensionjson-文件包含扩展的配置该文件具有以下结构nnjsonnn--name-my-extensionn--version-100n--mcpservers-n----my-server-n------command-node-my-serverjsn----n--n--contextfilename-vemdn--excludetools-run_shell_commandnnnn--name-扩展的名称这用于唯一标识扩展并在扩展命令与用户或项目命令同名时用于冲突解决n--version-扩展的版本n--mcpservers-要配置的-mcp-服务器映射键是服务器的名称值是服务器配置这些服务器将在启动时加载就像在--文件-中配置的-mcp-服务器一样如果扩展和-settingsjson-文件都配置了同名的-mcp-服务器则-settingsjson-文件中定义的服务器优先n--contextfilename-包含扩展上下文的文件名这将用于从工作区加载上下文如果未使用此属性但扩展目录中存在-vemd-文件则将加载该文件n--excludetools-要从模型中排除的工具名称数组您还可以为支持它的工具指定命令特定的限制例如-run_shell_command-工具例如excludetools-run_shell_commandrm--rf-将阻止-rm--rf-命令nn当-vecli-启动时它会加载所有扩展并合并其配置如果存在任何冲突工作区配置优先nn-扩展命令nn扩展可以通过在扩展目录内的-commands-子目录中放置-toml-文件来提供-自定义命令这些命令遵循与用户和项目自定义命令相同的格式并使用标准命名约定nn-示例nn一个名为-gcp-的扩展具有以下结构nnnvecliextensionsgcpn-vecli-extensionjsonn-commandsn-----deploytomln-----gcsn---------synctomlnnn将提供以下命令nn--deploy---在帮助中显示为-gcp-custom-command-from-deploytomln--gcssync---在帮助中显示为-gcp-custom-command-from-synctomlnn-冲突解决nn扩展命令具有最低优先级当与用户或项目命令发生冲突时nn1-无冲突-扩展命令使用其自然名称例如deployn2-有冲突-扩展命令使用扩展前缀重命名例如gcpdeploynn例如如果用户和-gcp-扩展都定义了一个-deploy-命令nn--deploy---执行用户的-deploy-命令n--gcpdeploy---执行扩展的-deploy-命令标记为-gcpnn-变量nnvecli-扩展允许在-vecli-extensionjson-中进行变量替换如果例如您需要当前目录来使用-cwd-extensionpathrunts-运行-mcp-服务器这将非常有用nn支持的变量nn-变量--------------------描述-----------------------------------------------------------------------------------------------------------------------------------------------------n---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------n-extensionpath----------用户文件系统中扩展的完全限定路径例如-usersusernamevecliextensionsexample-extension这不会展开符号链接-n--or-pathseparator--路径分隔符因操作系统而异----------------------------------------------------------------------------------------------------------------------------",children:["VeCLI 扩展\\n\\nVeCLI 支持可以用于配置和扩展其功能的扩展。\\n\\n## 工作原理\\n\\n在启动时，VeCLI 会在两个位置查找扩展：\\n\\n1.  ",(0,s.jsx)(e.code,{children:"<workspace>/.vecli/extensions"}),"\\n2.  ",(0,s.jsx)(e.code,{children:"<home>/.vecli/extensions"}),"\\n\\nVeCLI 从这两个位置加载所有扩展。如果两个位置都存在同名扩展，则工作区目录中的扩展优先。\\n\\n在每个位置内，单个扩展作为一个包含 ",(0,s.jsx)(e.code,{children:"vecli-extension.json"})," 文件的目录存在。例如：\\n\\n",(0,s.jsx)(e.code,{children:"<workspace>/.vecli/extensions/my-extension/vecli-extension.json"}),"\\n\\n### ",(0,s.jsx)(e.code,{children:"vecli-extension.json"}),"\\n\\n",(0,s.jsx)(e.code,{children:"vecli-extension.json"})," 文件包含扩展的配置。该文件具有以下结构：\\n\\n",(0,s.jsx)(e.code,{children:'json\\n{\\n  \\"name\\": \\"my-extension\\",\\n  \\"version\\": \\"1.0.0\\",\\n  \\"mcpServers\\": {\\n    \\"my-server\\": {\\n      \\"command\\": \\"node my-server.js\\"\\n    }\\n  },\\n  \\"contextFileName\\": \\"VE.md\\",\\n  \\"excludeTools\\": [\\"run_shell_command\\"]\\n}\\n'}),"\\n\\n- ",(0,s.jsx)(e.code,{children:"name"}),": 扩展的名称。这用于唯一标识扩展，并在扩展命令与用户或项目命令同名时用于冲突解决。\\n- ",(0,s.jsx)(e.code,{children:"version"}),": 扩展的版本。\\n- ",(0,s.jsx)(e.code,{children:"mcpServers"}),": 要配置的 MCP 服务器映射。键是服务器的名称，值是服务器配置。这些服务器将在启动时加载，就像在 ",(0,s.jsxs)(e.a,{href:"/zh/cli/configuration",children:[(0,s.jsx)(e.code,{children:"settings.json"})," 文件"]})," 中配置的 MCP 服务器一样。如果扩展和 ",(0,s.jsx)(e.code,{children:"settings.json"})," 文件都配置了同名的 MCP 服务器，则 ",(0,s.jsx)(e.code,{children:"settings.json"})," 文件中定义的服务器优先。\\n- ",(0,s.jsx)(e.code,{children:"contextFileName"}),": 包含扩展上下文的文件名。这将用于从工作区加载上下文。如果未使用此属性，但扩展目录中存在 ",(0,s.jsx)(e.code,{children:"VE.md"})," 文件，则将加载该文件。\\n- ",(0,s.jsx)(e.code,{children:"excludeTools"}),": 要从模型中排除的工具名称数组。您还可以为支持它的工具指定命令特定的限制，例如 ",(0,s.jsx)(e.code,{children:"run_shell_command"})," 工具。例如，",(0,s.jsx)(e.code,{children:'\\"excludeTools\\": [\\"run_shell_command(rm -rf)\\"]'})," 将阻止 ",(0,s.jsx)(e.code,{children:"rm -rf"})," 命令。\\n\\n当 VeCLI 启动时，它会加载所有扩展并合并其配置。如果存在任何冲突，工作区配置优先。\\n\\n## 扩展命令\\n\\n扩展可以通过在扩展目录内的 ",(0,s.jsx)(e.code,{children:"commands/"})," 子目录中放置 TOML 文件来提供 ",(0,s.jsx)(e.a,{href:"/zh/cli/commands#custom-commands",children:"自定义命令"}),"。这些命令遵循与用户和项目自定义命令相同的格式，并使用标准命名约定。\\n\\n### 示例\\n\\n一个名为 ",(0,s.jsx)(e.code,{children:"gcp"})," 的扩展具有以下结构：\\n\\n",(0,s.jsx)(e.code,{children:"\\n.vecli/extensions/gcp/\\n├── vecli-extension.json\\n└── commands/\\n    ├── deploy.toml\\n    └── gcs/\\n        └── sync.toml\\n"}),"\\n\\n将提供以下命令：\\n\\n- ",(0,s.jsx)(e.code,{children:"/deploy"})," - 在帮助中显示为 ",(0,s.jsx)(e.code,{children:"[gcp] Custom command from deploy.toml"}),"\\n- ",(0,s.jsx)(e.code,{children:"/gcs:sync"})," - 在帮助中显示为 ",(0,s.jsx)(e.code,{children:"[gcp] Custom command from sync.toml"}),"\\n\\n### 冲突解决\\n\\n扩展命令具有最低优先级。当与用户或项目命令发生冲突时：\\n\\n1. ",(0,s.jsx)(e.strong,{children:"无冲突"}),": 扩展命令使用其自然名称（例如，",(0,s.jsx)(e.code,{children:"/deploy"}),"）\\n2. ",(0,s.jsx)(e.strong,{children:"有冲突"}),": 扩展命令使用扩展前缀重命名（例如，",(0,s.jsx)(e.code,{children:"/gcp.deploy"}),"）\\n\\n例如，如果用户和 ",(0,s.jsx)(e.code,{children:"gcp"})," 扩展都定义了一个 ",(0,s.jsx)(e.code,{children:"deploy"})," 命令：\\n\\n- ",(0,s.jsx)(e.code,{children:"/deploy"})," - 执行用户的 deploy 命令\\n- ",(0,s.jsx)(e.code,{children:"/gcp.deploy"})," - 执行扩展的 deploy 命令（标记为 ",(0,s.jsx)(e.code,{children:"[gcp]"}),"）\\n\\n# 变量\\n\\nVeCLI 扩展允许在 ",(0,s.jsx)(e.code,{children:"vecli-extension.json"})," 中进行变量替换。如果例如您需要当前目录来使用 ",(0,s.jsx)(e.code,{children:'\\"cwd\\": \\"${extensionPath}${/}run.ts\\"'})," 运行 MCP 服务器，这将非常有用。\\n\\n",(0,s.jsx)(e.strong,{children:"支持的变量:"}),"\\n\\n| 变量                   | 描述                                                                                                                                                     |\\n| -------------------------- | --------------------------------------------------------------------------------------------------------------------------------------------------------------- |\\n| ",(0,s.jsx)(e.code,{children:"${extensionPath}"}),"         | 用户文件系统中扩展的完全限定路径，例如 '/Users/username/.vecli/extensions/example-extension'。这不会展开符号链接。 |\\n| ",(0,s.jsx)(e.code,{children:"${/} or ${pathSeparator}"})," | 路径分隔符（因操作系统而异）。                                                                                                                            |",(0,s.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#vecli-扩展nnvecli-支持可以用于配置和扩展其功能的扩展nn-工作原理nn在启动时vecli-会在两个位置查找扩展nn1--workspacevecliextensionsn2--homevecliextensionsnnvecli-从这两个位置加载所有扩展如果两个位置都存在同名扩展则工作区目录中的扩展优先nn在每个位置内单个扩展作为一个包含-vecli-extensionjson-文件的目录存在例如nnworkspacevecliextensionsmy-extensionvecli-extensionjsonnn-vecli-extensionjsonnnvecli-extensionjson-文件包含扩展的配置该文件具有以下结构nnjsonnn--name-my-extensionn--version-100n--mcpservers-n----my-server-n------command-node-my-serverjsn----n--n--contextfilename-vemdn--excludetools-run_shell_commandnnnn--name-扩展的名称这用于唯一标识扩展并在扩展命令与用户或项目命令同名时用于冲突解决n--version-扩展的版本n--mcpservers-要配置的-mcp-服务器映射键是服务器的名称值是服务器配置这些服务器将在启动时加载就像在--文件-中配置的-mcp-服务器一样如果扩展和-settingsjson-文件都配置了同名的-mcp-服务器则-settingsjson-文件中定义的服务器优先n--contextfilename-包含扩展上下文的文件名这将用于从工作区加载上下文如果未使用此属性但扩展目录中存在-vemd-文件则将加载该文件n--excludetools-要从模型中排除的工具名称数组您还可以为支持它的工具指定命令特定的限制例如-run_shell_command-工具例如excludetools-run_shell_commandrm--rf-将阻止-rm--rf-命令nn当-vecli-启动时它会加载所有扩展并合并其配置如果存在任何冲突工作区配置优先nn-扩展命令nn扩展可以通过在扩展目录内的-commands-子目录中放置-toml-文件来提供-自定义命令这些命令遵循与用户和项目自定义命令相同的格式并使用标准命名约定nn-示例nn一个名为-gcp-的扩展具有以下结构nnnvecliextensionsgcpn-vecli-extensionjsonn-commandsn-----deploytomln-----gcsn---------synctomlnnn将提供以下命令nn--deploy---在帮助中显示为-gcp-custom-command-from-deploytomln--gcssync---在帮助中显示为-gcp-custom-command-from-synctomlnn-冲突解决nn扩展命令具有最低优先级当与用户或项目命令发生冲突时nn1-无冲突-扩展命令使用其自然名称例如deployn2-有冲突-扩展命令使用扩展前缀重命名例如gcpdeploynn例如如果用户和-gcp-扩展都定义了一个-deploy-命令nn--deploy---执行用户的-deploy-命令n--gcpdeploy---执行扩展的-deploy-命令标记为-gcpnn-变量nnvecli-扩展允许在-vecli-extensionjson-中进行变量替换如果例如您需要当前目录来使用-cwd-extensionpathrunts-运行-mcp-服务器这将非常有用nn支持的变量nn-变量--------------------描述-----------------------------------------------------------------------------------------------------------------------------------------------------n---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------n-extensionpath----------用户文件系统中扩展的完全限定路径例如-usersusernamevecliextensionsexample-extension这不会展开符号链接-n--or-pathseparator--路径分隔符因操作系统而异----------------------------------------------------------------------------------------------------------------------------",children:"#"})]})}function i(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:e}=Object.assign({},(0,c.ah)(),n.components);return e?(0,s.jsx)(e,{...n,children:(0,s.jsx)(l,{...n})}):l(n)}let m=i;i.__RSPRESS_PAGE_META={},i.__RSPRESS_PAGE_META["zh%2Fextension.md"]={toc:[],title:'VeCLI 扩展\\n\\nVeCLI 支持可以用于配置和扩展其功能的扩展。\\n\\n## 工作原理\\n\\n在启动时，VeCLI 会在两个位置查找扩展：\\n\\n1.  `<workspace>/.vecli/extensions`\\n2.  `<home>/.vecli/extensions`\\n\\nVeCLI 从这两个位置加载所有扩展。如果两个位置都存在同名扩展，则工作区目录中的扩展优先。\\n\\n在每个位置内，单个扩展作为一个包含 `vecli-extension.json` 文件的目录存在。例如：\\n\\n`<workspace>/.vecli/extensions/my-extension/vecli-extension.json`\\n\\n### `vecli-extension.json`\\n\\n`vecli-extension.json` 文件包含扩展的配置。该文件具有以下结构：\\n\\n`json\\n{\\n  \\"name\\": \\"my-extension\\",\\n  \\"version\\": \\"1.0.0\\",\\n  \\"mcpServers\\": {\\n    \\"my-server\\": {\\n      \\"command\\": \\"node my-server.js\\"\\n    }\\n  },\\n  \\"contextFileName\\": \\"VE.md\\",\\n  \\"excludeTools\\": [\\"run_shell_command\\"]\\n}\\n`\\n\\n- `name`: 扩展的名称。这用于唯一标识扩展，并在扩展命令与用户或项目命令同名时用于冲突解决。\\n- `version`: 扩展的版本。\\n- `mcpServers`: 要配置的 MCP 服务器映射。键是服务器的名称，值是服务器配置。这些服务器将在启动时加载，就像在  中配置的 MCP 服务器一样。如果扩展和 `settings.json` 文件都配置了同名的 MCP 服务器，则 `settings.json` 文件中定义的服务器优先。\\n- `contextFileName`: 包含扩展上下文的文件名。这将用于从工作区加载上下文。如果未使用此属性，但扩展目录中存在 `VE.md` 文件，则将加载该文件。\\n- `excludeTools`: 要从模型中排除的工具名称数组。您还可以为支持它的工具指定命令特定的限制，例如 `run_shell_command` 工具。例如，`\\"excludeTools\\": [\\"run_shell_command(rm -rf)\\"]` 将阻止 `rm -rf` 命令。\\n\\n当 VeCLI 启动时，它会加载所有扩展并合并其配置。如果存在任何冲突，工作区配置优先。\\n\\n## 扩展命令\\n\\n扩展可以通过在扩展目录内的 `commands/` 子目录中放置 TOML 文件来提供 自定义命令。这些命令遵循与用户和项目自定义命令相同的格式，并使用标准命名约定。\\n\\n### 示例\\n\\n一个名为 `gcp` 的扩展具有以下结构：\\n\\n`\\n.vecli/extensions/gcp/\\n├── vecli-extension.json\\n└── commands/\\n    ├── deploy.toml\\n    └── gcs/\\n        └── sync.toml\\n`\\n\\n将提供以下命令：\\n\\n- `/deploy` - 在帮助中显示为 `[gcp] Custom command from deploy.toml`\\n- `/gcs:sync` - 在帮助中显示为 `[gcp] Custom command from sync.toml`\\n\\n### 冲突解决\\n\\n扩展命令具有最低优先级。当与用户或项目命令发生冲突时：\\n\\n1. **无冲突**: 扩展命令使用其自然名称（例如，`/deploy`）\\n2. **有冲突**: 扩展命令使用扩展前缀重命名（例如，`/gcp.deploy`）\\n\\n例如，如果用户和 `gcp` 扩展都定义了一个 `deploy` 命令：\\n\\n- `/deploy` - 执行用户的 deploy 命令\\n- `/gcp.deploy` - 执行扩展的 deploy 命令（标记为 `[gcp]`）\\n\\n# 变量\\n\\nVeCLI 扩展允许在 `vecli-extension.json` 中进行变量替换。如果例如您需要当前目录来使用 `\\"cwd\\": \\"${extensionPath}${/}run.ts\\"` 运行 MCP 服务器，这将非常有用。\\n\\n**支持的变量:**\\n\\n| 变量                   | 描述                                                                                                                                                     |\\n| -------------------------- | --------------------------------------------------------------------------------------------------------------------------------------------------------------- |\\n| `${extensionPath}`         | 用户文件系统中扩展的完全限定路径，例如 \'/Users/username/.vecli/extensions/example-extension\'。这不会展开符号链接。 |\\n| `${/} or ${pathSeparator}` | 路径分隔符（因操作系统而异）。                                                                                                                            |',headingTitle:'VeCLI 扩展\\n\\nVeCLI 支持可以用于配置和扩展其功能的扩展。\\n\\n## 工作原理\\n\\n在启动时，VeCLI 会在两个位置查找扩展：\\n\\n1.  `<workspace>/.vecli/extensions`\\n2.  `<home>/.vecli/extensions`\\n\\nVeCLI 从这两个位置加载所有扩展。如果两个位置都存在同名扩展，则工作区目录中的扩展优先。\\n\\n在每个位置内，单个扩展作为一个包含 `vecli-extension.json` 文件的目录存在。例如：\\n\\n`<workspace>/.vecli/extensions/my-extension/vecli-extension.json`\\n\\n### `vecli-extension.json`\\n\\n`vecli-extension.json` 文件包含扩展的配置。该文件具有以下结构：\\n\\n`json\\n{\\n  \\"name\\": \\"my-extension\\",\\n  \\"version\\": \\"1.0.0\\",\\n  \\"mcpServers\\": {\\n    \\"my-server\\": {\\n      \\"command\\": \\"node my-server.js\\"\\n    }\\n  },\\n  \\"contextFileName\\": \\"VE.md\\",\\n  \\"excludeTools\\": [\\"run_shell_command\\"]\\n}\\n`\\n\\n- `name`: 扩展的名称。这用于唯一标识扩展，并在扩展命令与用户或项目命令同名时用于冲突解决。\\n- `version`: 扩展的版本。\\n- `mcpServers`: 要配置的 MCP 服务器映射。键是服务器的名称，值是服务器配置。这些服务器将在启动时加载，就像在  中配置的 MCP 服务器一样。如果扩展和 `settings.json` 文件都配置了同名的 MCP 服务器，则 `settings.json` 文件中定义的服务器优先。\\n- `contextFileName`: 包含扩展上下文的文件名。这将用于从工作区加载上下文。如果未使用此属性，但扩展目录中存在 `VE.md` 文件，则将加载该文件。\\n- `excludeTools`: 要从模型中排除的工具名称数组。您还可以为支持它的工具指定命令特定的限制，例如 `run_shell_command` 工具。例如，`\\"excludeTools\\": [\\"run_shell_command(rm -rf)\\"]` 将阻止 `rm -rf` 命令。\\n\\n当 VeCLI 启动时，它会加载所有扩展并合并其配置。如果存在任何冲突，工作区配置优先。\\n\\n## 扩展命令\\n\\n扩展可以通过在扩展目录内的 `commands/` 子目录中放置 TOML 文件来提供 自定义命令。这些命令遵循与用户和项目自定义命令相同的格式，并使用标准命名约定。\\n\\n### 示例\\n\\n一个名为 `gcp` 的扩展具有以下结构：\\n\\n`\\n.vecli/extensions/gcp/\\n├── vecli-extension.json\\n└── commands/\\n    ├── deploy.toml\\n    └── gcs/\\n        └── sync.toml\\n`\\n\\n将提供以下命令：\\n\\n- `/deploy` - 在帮助中显示为 `[gcp] Custom command from deploy.toml`\\n- `/gcs:sync` - 在帮助中显示为 `[gcp] Custom command from sync.toml`\\n\\n### 冲突解决\\n\\n扩展命令具有最低优先级。当与用户或项目命令发生冲突时：\\n\\n1. **无冲突**: 扩展命令使用其自然名称（例如，`/deploy`）\\n2. **有冲突**: 扩展命令使用扩展前缀重命名（例如，`/gcp.deploy`）\\n\\n例如，如果用户和 `gcp` 扩展都定义了一个 `deploy` 命令：\\n\\n- `/deploy` - 执行用户的 deploy 命令\\n- `/gcp.deploy` - 执行扩展的 deploy 命令（标记为 `[gcp]`）\\n\\n# 变量\\n\\nVeCLI 扩展允许在 `vecli-extension.json` 中进行变量替换。如果例如您需要当前目录来使用 `\\"cwd\\": \\"${extensionPath}${/}run.ts\\"` 运行 MCP 服务器，这将非常有用。\\n\\n**支持的变量:**\\n\\n| 变量                   | 描述                                                                                                                                                     |\\n| -------------------------- | --------------------------------------------------------------------------------------------------------------------------------------------------------------- |\\n| `${extensionPath}`         | 用户文件系统中扩展的完全限定路径，例如 \'/Users/username/.vecli/extensions/example-extension\'。这不会展开符号链接。 |\\n| `${/} or ${pathSeparator}` | 路径分隔符（因操作系统而异）。                                                                                                                            |',frontmatter:{}}}}]);