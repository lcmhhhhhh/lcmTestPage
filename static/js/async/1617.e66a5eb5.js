"use strict";(self.webpackChunklcm_test_page=self.webpackChunklcm_test_page||[]).push([["1617"],{7546:function(e,c,n){n.r(c),n.d(c,{default:()=>d});var i=n(5893),l=n(65);function r(e){let c=Object.assign({h1:"h1",a:"a",p:"p",code:"code",h2:"h2",h3:"h3",pre:"pre",ul:"ul",li:"li",strong:"strong"},(0,l.ah)(),e.components);return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsxs)(c.h1,{id:"包概述",children:["包概述",(0,i.jsx)(c.a,{className:"header-anchor","aria-hidden":"true",href:"#包概述",children:"#"})]}),"\n",(0,i.jsxs)(c.p,{children:["此 monorepo 包含两个主要包：",(0,i.jsx)(c.code,{children:"@vecli/vecli"})," 和 ",(0,i.jsx)(c.code,{children:"@vecli/vecli-core"}),"。"]}),"\n",(0,i.jsxs)(c.h2,{id:"veclivecli",children:[(0,i.jsx)(c.code,{children:"@vecli/vecli"}),(0,i.jsx)(c.a,{className:"header-anchor","aria-hidden":"true",href:"#veclivecli",children:"#"})]}),"\n",(0,i.jsx)(c.p,{children:"这是 VeCLI 的主包。它负责用户界面、命令解析以及所有其他面向用户的功能。"}),"\n",(0,i.jsxs)(c.p,{children:["发布此包时，它会被捆绑成一个可执行文件。此捆绑包包括该包的所有依赖项，包括 ",(0,i.jsx)(c.code,{children:"@vecli/vecli-core"}),"。这意味着无论用户是使用 ",(0,i.jsx)(c.code,{children:"npm install -g @vecli/vecli"})," 安装该包，还是直接使用 ",(0,i.jsx)(c.code,{children:"npx @vecli/vecli"})," 运行它，他们都在使用这个单一的、自包含的可执行文件。"]}),"\n",(0,i.jsxs)(c.h2,{id:"veclivecli-core",children:[(0,i.jsx)(c.code,{children:"@vecli/vecli-core"}),(0,i.jsx)(c.a,{className:"header-anchor","aria-hidden":"true",href:"#veclivecli-core",children:"#"})]}),"\n",(0,i.jsx)(c.p,{children:"此包包含与火山引擎 API 交互的核心逻辑。它负责发出 API 请求、处理身份验证和管理本地缓存。"}),"\n",(0,i.jsxs)(c.p,{children:["此包未被捆绑。发布时，它作为一个标准的 Node.js 包发布，具有自己的依赖项。这允许在需要时将其作为独立包在其他项目中使用。",(0,i.jsx)(c.code,{children:"dist"})," 文件夹中的所有转译后的 js 代码都包含在包中。"]}),"\n",(0,i.jsxs)(c.h2,{id:"npm-工作区",children:["NPM 工作区",(0,i.jsx)(c.a,{className:"header-anchor","aria-hidden":"true",href:"#npm-工作区",children:"#"})]}),"\n",(0,i.jsxs)(c.p,{children:["此项目使用 ",(0,i.jsx)(c.a,{href:"https://docs.npmjs.com/cli/v10/using-npm/workspaces",target:"_blank",rel:"noopener noreferrer",children:"NPM 工作区"})," 来管理此 monorepo 中的包。这简化了开发，因为它允许我们从项目根目录管理依赖项并在多个包中运行脚本。"]}),"\n",(0,i.jsxs)(c.h3,{id:"工作原理",children:["工作原理",(0,i.jsx)(c.a,{className:"header-anchor","aria-hidden":"true",href:"#工作原理",children:"#"})]}),"\n",(0,i.jsxs)(c.p,{children:["根 ",(0,i.jsx)(c.code,{children:"package.json"})," 文件定义了此项目的工作区："]}),"\n",(0,i.jsx)(c.pre,{children:(0,i.jsx)(c.code,{className:"language-json",children:'{\n  "workspaces": ["packages/*"]\n}\n'})}),"\n",(0,i.jsxs)(c.p,{children:["这告诉 NPM，",(0,i.jsx)(c.code,{children:"packages"})," 目录中的任何文件夹都是一个单独的包，应作为工作区的一部分进行管理。"]}),"\n",(0,i.jsxs)(c.h3,{id:"工作区的优势",children:["工作区的优势",(0,i.jsx)(c.a,{className:"header-anchor","aria-hidden":"true",href:"#工作区的优势",children:"#"})]}),"\n",(0,i.jsxs)(c.ul,{children:["\n",(0,i.jsxs)(c.li,{children:[(0,i.jsx)(c.strong,{children:"简化的依赖管理"}),"：从项目根目录运行 ",(0,i.jsx)(c.code,{children:"npm install"})," 将安装工作区中所有包的依赖项并将它们链接在一起。这意味着您无需在每个包的目录中运行 ",(0,i.jsx)(c.code,{children:"npm install"}),"。"]}),"\n",(0,i.jsxs)(c.li,{children:[(0,i.jsx)(c.strong,{children:"自动链接"}),"：工作区内的包可以相互依赖。运行 ",(0,i.jsx)(c.code,{children:"npm install"})," 时，NPM 将自动在包之间创建符号链接。这意味着当您对一个包进行更改时，这些更改会立即对其依赖的其他包可用。"]}),"\n",(0,i.jsxs)(c.li,{children:[(0,i.jsx)(c.strong,{children:"简化的脚本执行"}),"：您可以使用 ",(0,i.jsx)(c.code,{children:"--workspace"})," 标志从项目根目录运行任何包中的脚本。例如，要在 ",(0,i.jsx)(c.code,{children:"cli"})," 包中运行 ",(0,i.jsx)(c.code,{children:"build"})," 脚本，您可以运行 ",(0,i.jsx)(c.code,{children:"npm run build --workspace @vecli/vecli"}),"。"]}),"\n"]})]})}function s(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:c}=Object.assign({},(0,l.ah)(),e.components);return c?(0,i.jsx)(c,{...e,children:(0,i.jsx)(r,{...e})}):r(e)}let d=s;s.__RSPRESS_PAGE_META={},s.__RSPRESS_PAGE_META["zh%2Fnpm.md"]={toc:[{text:"`@vecli/vecli`",id:"veclivecli",depth:2},{text:"`@vecli/vecli-core`",id:"veclivecli-core",depth:2},{text:"NPM 工作区",id:"npm-工作区",depth:2},{text:"工作原理",id:"工作原理",depth:3},{text:"工作区的优势",id:"工作区的优势",depth:3}],title:"包概述",headingTitle:"包概述",frontmatter:{}}}}]);