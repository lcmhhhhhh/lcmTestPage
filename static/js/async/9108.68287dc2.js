"use strict";(self.webpackChunklcm_test_page=self.webpackChunklcm_test_page||[]).push([["9108"],{453:function(e,n,s){s.r(n),s.d(n,{default:()=>d});var c=s(5893),i=s(65);function r(e){let n=Object.assign({h1:"h1",a:"a",p:"p",h2:"h2",hr:"hr",h3:"h3",ul:"ul",li:"li",strong:"strong",pre:"pre",code:"code",ol:"ol"},(0,i.ah)(),e.components);return(0,c.jsxs)(c.Fragment,{children:[(0,c.jsxs)(n.h1,{id:"vecli-执行和部署",children:["VeCLI 执行和部署",(0,c.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#vecli-执行和部署",children:"#"})]}),"\n",(0,c.jsx)(n.p,{children:"本文档描述了如何运行 VeCLI 并解释 VeCLI 使用的部署架构。"}),"\n",(0,c.jsxs)(n.h2,{id:"运行-vecli",children:["运行 VeCLI",(0,c.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#运行-vecli",children:"#"})]}),"\n",(0,c.jsx)(n.p,{children:"有几种方法可以运行 VeCLI。您选择的选项取决于您打算如何使用 VeCLI。"}),"\n",(0,c.jsx)(n.hr,{}),"\n",(0,c.jsxs)(n.h3,{id:"1-标准安装推荐给典型用户",children:["1. 标准安装（推荐给典型用户）",(0,c.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#1-标准安装推荐给典型用户",children:"#"})]}),"\n",(0,c.jsx)(n.p,{children:"这是推荐给最终用户安装 VeCLI 的方式。它涉及从 NPM 注册表下载 VeCLI 包。"}),"\n",(0,c.jsxs)(n.ul,{children:["\n",(0,c.jsxs)(n.li,{children:["\n",(0,c.jsx)(n.p,{children:(0,c.jsx)(n.strong,{children:"全局安装："})}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-bash",children:"npm install -g @vecli/vecli\n"})}),"\n",(0,c.jsx)(n.p,{children:"然后，从任何地方运行 CLI："}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-bash",children:"vecli\n"})}),"\n"]}),"\n",(0,c.jsxs)(n.li,{children:["\n",(0,c.jsx)(n.p,{children:(0,c.jsx)(n.strong,{children:"NPX 执行："})}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-bash",children:"# 从 NPM 执行最新版本，无需全局安装\nnpx @vecli/vecli\n"})}),"\n"]}),"\n"]}),"\n",(0,c.jsx)(n.hr,{}),"\n",(0,c.jsxs)(n.h3,{id:"2-在沙盒中运行dockerpodman",children:["2. 在沙盒中运行（Docker/Podman）",(0,c.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#2-在沙盒中运行dockerpodman",children:"#"})]}),"\n",(0,c.jsx)(n.p,{children:"为了安全和隔离，VeCLI 可以在容器内运行。这是 CLI 执行可能有副作用的工具的默认方式。"}),"\n",(0,c.jsxs)(n.ul,{children:["\n",(0,c.jsxs)(n.li,{children:[(0,c.jsx)(n.strong,{children:"直接从注册表运行："}),"\n您可以直接运行已发布的沙盒镜像。这对于只有 Docker 并且想要运行 CLI 的环境很有用。","\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-bash",children:"# 运行已发布的沙盒镜像\ndocker run --rm -it us-docker.pkg.dev/vecli-code-dev/vecli/sandbox:0.1.1\n"})}),"\n"]}),"\n",(0,c.jsxs)(n.li,{children:[(0,c.jsxs)(n.strong,{children:["使用 ",(0,c.jsx)(n.code,{children:"--sandbox"})," 标志："]}),"\n如果您在本地安装了 VeCLI（使用上述标准安装），您可以指示它在沙盒容器内运行。","\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-bash",children:'vecli --sandbox -y -p "your prompt here"\n'})}),"\n"]}),"\n"]}),"\n",(0,c.jsx)(n.hr,{}),"\n",(0,c.jsxs)(n.h3,{id:"3-从源代码运行推荐给-vecli-贡献者",children:["3. 从源代码运行（推荐给 VeCLI 贡献者）",(0,c.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#3-从源代码运行推荐给-vecli-贡献者",children:"#"})]}),"\n",(0,c.jsx)(n.p,{children:"项目的贡献者将希望直接从源代码运行 CLI。"}),"\n",(0,c.jsxs)(n.ul,{children:["\n",(0,c.jsxs)(n.li,{children:["\n",(0,c.jsxs)(n.p,{children:[(0,c.jsx)(n.strong,{children:"开发模式："}),"\n此方法提供热重载，对积极开发很有用。"]}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-bash",children:"# 从存储库的根目录\nnpm run start\n"})}),"\n"]}),"\n",(0,c.jsxs)(n.li,{children:["\n",(0,c.jsxs)(n.p,{children:[(0,c.jsx)(n.strong,{children:"类似生产的模式（链接包）："}),"\n此方法通过链接您的本地包来模拟全局安装。这对于在生产工作流中测试本地构建很有用。"]}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-bash",children:"# 将本地 cli 包链接到您的全局 node_modules\nnpm link packages/cli\n\n# 现在您可以使用 `vecli` 命令运行您的本地版本\nvecli\n"})}),"\n"]}),"\n"]}),"\n",(0,c.jsx)(n.hr,{}),"\n",(0,c.jsxs)(n.h3,{id:"4-从-github-运行最新的-vecli-提交",children:["4. 从 GitHub 运行最新的 VeCLI 提交",(0,c.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#4-从-github-运行最新的-vecli-提交",children:"#"})]}),"\n",(0,c.jsx)(n.p,{children:"您可以直接从 GitHub 存储库运行最近提交的 VeCLI 版本。这对于测试仍在开发中的功能很有用。"}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-bash",children:"# 直接从 GitHub 上的 main 分支执行 CLI\nnpx https://github.com/volcengine/vecli\n"})}),"\n",(0,c.jsxs)(n.h2,{id:"部署架构",children:["部署架构",(0,c.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#部署架构",children:"#"})]}),"\n",(0,c.jsx)(n.p,{children:"上述执行方法由以下架构组件和流程实现："}),"\n",(0,c.jsx)(n.p,{children:(0,c.jsx)(n.strong,{children:"NPM 包"})}),"\n",(0,c.jsx)(n.p,{children:"VeCLI 项目是一个 monorepo，将两个核心包发布到 NPM 注册表："}),"\n",(0,c.jsxs)(n.ul,{children:["\n",(0,c.jsxs)(n.li,{children:[(0,c.jsx)(n.code,{children:"@vecli/vecli-core"}),"：后端，处理逻辑和工具执行。"]}),"\n",(0,c.jsxs)(n.li,{children:[(0,c.jsx)(n.code,{children:"@vecli/vecli"}),"：面向用户的前端。"]}),"\n"]}),"\n",(0,c.jsx)(n.p,{children:"在执行标准安装和从源代码运行 VeCLI 时会使用这些包。"}),"\n",(0,c.jsx)(n.p,{children:(0,c.jsx)(n.strong,{children:"构建和打包流程"})}),"\n",(0,c.jsx)(n.p,{children:"根据分发渠道，使用两种不同的构建流程："}),"\n",(0,c.jsxs)(n.ul,{children:["\n",(0,c.jsxs)(n.li,{children:["\n",(0,c.jsxs)(n.p,{children:[(0,c.jsx)(n.strong,{children:"NPM 发布："})," 对于发布到 NPM 注册表，",(0,c.jsx)(n.code,{children:"@vecli/vecli-core"})," 和 ",(0,c.jsx)(n.code,{children:"@vecli/vecli"})," 中的 TypeScript 源代码使用 TypeScript 编译器 (",(0,c.jsx)(n.code,{children:"tsc"}),") 转译为标准 JavaScript。生成的 ",(0,c.jsx)(n.code,{children:"dist/"})," 目录是 NPM 包中发布的内容。这是 TypeScript 库的标准方法。"]}),"\n"]}),"\n",(0,c.jsxs)(n.li,{children:["\n",(0,c.jsxs)(n.p,{children:[(0,c.jsxs)(n.strong,{children:["GitHub ",(0,c.jsx)(n.code,{children:"npx"})," 执行："]})," 当直接从 GitHub 运行最新版本的 VeCLI 时，",(0,c.jsx)(n.code,{children:"package.json"})," 中的 ",(0,c.jsx)(n.code,{children:"prepare"})," 脚本会触发不同的流程。该脚本使用 ",(0,c.jsx)(n.code,{children:"esbuild"})," 将整个应用程序及其依赖项捆绑到一个单一的、自包含的 JavaScript 文件中。此捆绑包在用户的机器上即时创建，不会签入存储库。"]}),"\n"]}),"\n"]}),"\n",(0,c.jsx)(n.p,{children:(0,c.jsx)(n.strong,{children:"Docker 沙盒镜像"})}),"\n",(0,c.jsxs)(n.p,{children:["基于 Docker 的执行方法由 ",(0,c.jsx)(n.code,{children:"vecli-sandbox"})," 容器镜像支持。此镜像发布到容器注册表，包含预安装的全局 VeCLI 版本。"]}),"\n",(0,c.jsxs)(n.h2,{id:"发布流程",children:["发布流程",(0,c.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#发布流程",children:"#"})]}),"\n",(0,c.jsx)(n.p,{children:"发布流程通过 GitHub Actions 自动化。发布工作流执行以下操作："}),"\n",(0,c.jsxs)(n.ol,{children:["\n",(0,c.jsxs)(n.li,{children:["使用 ",(0,c.jsx)(n.code,{children:"tsc"})," 构建 NPM 包。"]}),"\n",(0,c.jsx)(n.li,{children:"将 NPM 包发布到工件注册表。"}),"\n",(0,c.jsx)(n.li,{children:"创建包含捆绑资产的 GitHub 发布。"}),"\n"]})]})}function l(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:n}=Object.assign({},(0,i.ah)(),e.components);return n?(0,c.jsx)(n,{...e,children:(0,c.jsx)(r,{...e})}):r(e)}let d=l;l.__RSPRESS_PAGE_META={},l.__RSPRESS_PAGE_META["zh%2Fdeployment.md"]={toc:[{text:"运行 VeCLI",id:"运行-vecli",depth:2},{text:"1. 标准安装（推荐给典型用户）",id:"1-标准安装推荐给典型用户",depth:3},{text:"2. 在沙盒中运行（Docker/Podman）",id:"2-在沙盒中运行dockerpodman",depth:3},{text:"3. 从源代码运行（推荐给 VeCLI 贡献者）",id:"3-从源代码运行推荐给-vecli-贡献者",depth:3},{text:"4. 从 GitHub 运行最新的 VeCLI 提交",id:"4-从-github-运行最新的-vecli-提交",depth:3},{text:"部署架构",id:"部署架构",depth:2},{text:"发布流程",id:"发布流程",depth:2}],title:"VeCLI 执行和部署",headingTitle:"VeCLI 执行和部署",frontmatter:{}}}}]);