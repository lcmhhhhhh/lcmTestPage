"use strict";(self.webpackChunklcm_test_page=self.webpackChunklcm_test_page||[]).push([["9440"],{1537:function(e,d,r){r.r(d),r.d(d,{default:()=>a});var n=r(5893),s=r(65);function i(e){let d=Object.assign({h1:"h1",a:"a",p:"p",code:"code",h2:"h2",pre:"pre",h3:"h3",ul:"ul",li:"li",strong:"strong",ol:"ol"},(0,s.ah)(),e.components);return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsxs)(d.h1,{id:"内存导入处理器",children:["内存导入处理器",(0,n.jsx)(d.a,{className:"header-anchor","aria-hidden":"true",href:"#内存导入处理器",children:"#"})]}),"\n",(0,n.jsxs)(d.p,{children:["内存导入处理器是一个功能，允许您通过使用 ",(0,n.jsx)(d.code,{children:"@file.md"})," 语法从其他文件导入内容来模块化您的 VE.md 文件。"]}),"\n",(0,n.jsxs)(d.h2,{id:"概述",children:["概述",(0,n.jsx)(d.a,{className:"header-anchor","aria-hidden":"true",href:"#概述",children:"#"})]}),"\n",(0,n.jsx)(d.p,{children:"此功能使您能够将大型 VE.md 文件分解为更小、更易管理的组件，这些组件可以在不同上下文中重用。导入处理器支持相对路径和绝对路径，具有内置安全功能以防止循环导入并确保文件访问安全。"}),"\n",(0,n.jsxs)(d.h2,{id:"语法",children:["语法",(0,n.jsx)(d.a,{className:"header-anchor","aria-hidden":"true",href:"#语法",children:"#"})]}),"\n",(0,n.jsxs)(d.p,{children:["使用 ",(0,n.jsx)(d.code,{children:"@"})," 符号后跟您要导入的文件路径："]}),"\n",(0,n.jsx)(d.pre,{children:(0,n.jsx)(d.code,{className:"language-markdown",children:"# 主 VE.md 文件\n\n这是主要内容。\n\n@./components/instructions.md\n\n这里有更多内容。\n\n@./shared/configuration.md\n"})}),"\n",(0,n.jsxs)(d.h2,{id:"支持的路径格式",children:["支持的路径格式",(0,n.jsx)(d.a,{className:"header-anchor","aria-hidden":"true",href:"#支持的路径格式",children:"#"})]}),"\n",(0,n.jsxs)(d.h3,{id:"相对路径",children:["相对路径",(0,n.jsx)(d.a,{className:"header-anchor","aria-hidden":"true",href:"#相对路径",children:"#"})]}),"\n",(0,n.jsxs)(d.ul,{children:["\n",(0,n.jsxs)(d.li,{children:[(0,n.jsx)(d.code,{children:"@./file.md"})," - 从同一目录导入"]}),"\n",(0,n.jsxs)(d.li,{children:[(0,n.jsx)(d.code,{children:"@../file.md"})," - 从父目录导入"]}),"\n",(0,n.jsxs)(d.li,{children:[(0,n.jsx)(d.code,{children:"@./components/file.md"})," - 从子目录导入"]}),"\n"]}),"\n",(0,n.jsxs)(d.h3,{id:"绝对路径",children:["绝对路径",(0,n.jsx)(d.a,{className:"header-anchor","aria-hidden":"true",href:"#绝对路径",children:"#"})]}),"\n",(0,n.jsxs)(d.ul,{children:["\n",(0,n.jsxs)(d.li,{children:[(0,n.jsx)(d.code,{children:"@/absolute/path/to/file.md"})," - 使用绝对路径导入"]}),"\n"]}),"\n",(0,n.jsxs)(d.h2,{id:"示例",children:["示例",(0,n.jsx)(d.a,{className:"header-anchor","aria-hidden":"true",href:"#示例",children:"#"})]}),"\n",(0,n.jsxs)(d.h3,{id:"基本导入",children:["基本导入",(0,n.jsx)(d.a,{className:"header-anchor","aria-hidden":"true",href:"#基本导入",children:"#"})]}),"\n",(0,n.jsx)(d.pre,{children:(0,n.jsx)(d.code,{className:"language-markdown",children:"# 我的 VE.md\n\n欢迎来到我的项目！\n\n@./getting-started.md\n\n## 功能\n\n@./features/overview.md\n"})}),"\n",(0,n.jsxs)(d.h3,{id:"嵌套导入",children:["嵌套导入",(0,n.jsx)(d.a,{className:"header-anchor","aria-hidden":"true",href:"#嵌套导入",children:"#"})]}),"\n",(0,n.jsx)(d.p,{children:"导入的文件本身可以包含导入，创建嵌套结构："}),"\n",(0,n.jsx)(d.pre,{children:(0,n.jsx)(d.code,{className:"language-markdown",children:"# main.md\n\n@./header.md\n@./content.md\n@./footer.md\n"})}),"\n",(0,n.jsx)(d.pre,{children:(0,n.jsx)(d.code,{className:"language-markdown",children:"# header.md\n\n# 项目标题\n\n@./shared/title.md\n"})}),"\n",(0,n.jsxs)(d.h2,{id:"安全功能",children:["安全功能",(0,n.jsx)(d.a,{className:"header-anchor","aria-hidden":"true",href:"#安全功能",children:"#"})]}),"\n",(0,n.jsxs)(d.h3,{id:"循环导入检测",children:["循环导入检测",(0,n.jsx)(d.a,{className:"header-anchor","aria-hidden":"true",href:"#循环导入检测",children:"#"})]}),"\n",(0,n.jsx)(d.p,{children:"处理器自动检测并防止循环导入："}),"\n",(0,n.jsx)(d.pre,{children:(0,n.jsx)(d.code,{className:"language-markdown",children:"# file-a.md\n\n@./file-b.md\n\n# file-b.md\n\n@./file-a.md \x3c!-- 这将被检测并阻止 --\x3e\n"})}),"\n",(0,n.jsxs)(d.h3,{id:"文件访问安全",children:["文件访问安全",(0,n.jsx)(d.a,{className:"header-anchor","aria-hidden":"true",href:"#文件访问安全",children:"#"})]}),"\n",(0,n.jsxs)(d.p,{children:[(0,n.jsx)(d.code,{children:"validateImportPath"})," 函数确保只允许从指定目录导入，防止访问允许范围外的敏感文件。"]}),"\n",(0,n.jsxs)(d.h3,{id:"最大导入深度",children:["最大导入深度",(0,n.jsx)(d.a,{className:"header-anchor","aria-hidden":"true",href:"#最大导入深度",children:"#"})]}),"\n",(0,n.jsx)(d.p,{children:"为了防止无限递归，有一个可配置的最大导入深度（默认：5 级）。"}),"\n",(0,n.jsxs)(d.h2,{id:"错误处理",children:["错误处理",(0,n.jsx)(d.a,{className:"header-anchor","aria-hidden":"true",href:"#错误处理",children:"#"})]}),"\n",(0,n.jsxs)(d.h3,{id:"缺失文件",children:["缺失文件",(0,n.jsx)(d.a,{className:"header-anchor","aria-hidden":"true",href:"#缺失文件",children:"#"})]}),"\n",(0,n.jsx)(d.p,{children:"如果引用的文件不存在，导入将优雅地失败，并在输出中显示错误注释。"}),"\n",(0,n.jsxs)(d.h3,{id:"文件访问错误",children:["文件访问错误",(0,n.jsx)(d.a,{className:"header-anchor","aria-hidden":"true",href:"#文件访问错误",children:"#"})]}),"\n",(0,n.jsx)(d.p,{children:"权限问题或其他文件系统错误会通过适当的错误消息优雅地处理。"}),"\n",(0,n.jsxs)(d.h2,{id:"代码区域检测",children:["代码区域检测",(0,n.jsx)(d.a,{className:"header-anchor","aria-hidden":"true",href:"#代码区域检测",children:"#"})]}),"\n",(0,n.jsxs)(d.p,{children:["导入处理器使用 ",(0,n.jsx)(d.code,{children:"marked"})," 库来检测代码块和内联代码段，确保这些区域内的 ",(0,n.jsx)(d.code,{children:"@"})," 导入被正确忽略。这提供了对嵌套代码块和复杂 Markdown 结构的强大处理。"]}),"\n",(0,n.jsxs)(d.h2,{id:"导入树结构",children:["导入树结构",(0,n.jsx)(d.a,{className:"header-anchor","aria-hidden":"true",href:"#导入树结构",children:"#"})]}),"\n",(0,n.jsxs)(d.p,{children:["处理器返回一个导入树，显示导入文件的层次结构，类似于 Claude 的 ",(0,n.jsx)(d.code,{children:"/memory"})," 功能。这通过显示读取了哪些文件及其导入关系来帮助用户调试 VE.md 文件的问题。"]}),"\n",(0,n.jsx)(d.p,{children:"示例树结构："}),"\n",(0,n.jsx)(d.pre,{children:(0,n.jsx)(d.code,{children:"Memory Files\n L project: VE.md\n            L a.md\n              L b.md\n                L c.md\n              L d.md\n                L e.md\n                  L f.md\n            L included.md\n"})}),"\n",(0,n.jsx)(d.p,{children:"树保留了文件导入的顺序，并显示完整的导入链以供调试。"}),"\n",(0,n.jsxs)(d.h2,{id:"与-claude-code-的-memoryclaudemd方法的比较",children:["与 Claude Code 的 ",(0,n.jsx)(d.code,{children:"/memory"}),"（",(0,n.jsx)(d.code,{children:"claude.md"}),"）方法的比较",(0,n.jsx)(d.a,{className:"header-anchor","aria-hidden":"true",href:"#与-claude-code-的-memoryclaudemd方法的比较",children:"#"})]}),"\n",(0,n.jsxs)(d.p,{children:["Claude Code 的 ",(0,n.jsx)(d.code,{children:"/memory"})," 功能（如 ",(0,n.jsx)(d.code,{children:"claude.md"})," 中所见）通过连接所有包含的文件产生一个扁平的线性文档，始终用清晰的注释和路径名标记文件边界。它不明确呈现导入层次结构，但 LLM 接收所有文件内容和路径，这足以在需要时重建层次结构。"]}),"\n",(0,n.jsx)(d.p,{children:"注意：导入树主要用于开发期间的清晰度，对 LLM 消费的相关性有限。"}),"\n",(0,n.jsxs)(d.h2,{id:"api-参考",children:["API 参考",(0,n.jsx)(d.a,{className:"header-anchor","aria-hidden":"true",href:"#api-参考",children:"#"})]}),"\n",(0,n.jsxs)(d.h3,{id:"processimportscontent-basepath-debugmode-importstate",children:[(0,n.jsx)(d.code,{children:"processImports(content, basePath, debugMode?, importState?)"}),(0,n.jsx)(d.a,{className:"header-anchor","aria-hidden":"true",href:"#processimportscontent-basepath-debugmode-importstate",children:"#"})]}),"\n",(0,n.jsx)(d.p,{children:"处理 VE.md 内容中的导入语句。"}),"\n",(0,n.jsx)(d.p,{children:(0,n.jsx)(d.strong,{children:"参数："})}),"\n",(0,n.jsxs)(d.ul,{children:["\n",(0,n.jsxs)(d.li,{children:[(0,n.jsx)(d.code,{children:"content"}),"（字符串）：要处理导入的内容"]}),"\n",(0,n.jsxs)(d.li,{children:[(0,n.jsx)(d.code,{children:"basePath"}),"（字符串）：当前文件所在的目录路径"]}),"\n",(0,n.jsxs)(d.li,{children:[(0,n.jsx)(d.code,{children:"debugMode"}),"（布尔值，可选）：是否启用调试日志记录（默认：false）"]}),"\n",(0,n.jsxs)(d.li,{children:[(0,n.jsx)(d.code,{children:"importState"}),"（ImportState，可选）：用于循环导入防护的状态跟踪"]}),"\n"]}),"\n",(0,n.jsxs)(d.p,{children:[(0,n.jsx)(d.strong,{children:"返回："})," Promise"," - 包含处理内容和导入树的对象"]}),"\n",(0,n.jsxs)(d.h3,{id:"processimportsresult",children:[(0,n.jsx)(d.code,{children:"ProcessImportsResult"}),(0,n.jsx)(d.a,{className:"header-anchor","aria-hidden":"true",href:"#processimportsresult",children:"#"})]}),"\n",(0,n.jsx)(d.pre,{children:(0,n.jsx)(d.code,{className:"language-typescript",children:"interface ProcessImportsResult {\n  content: string; // 解析导入后的处理内容\n  importTree: MemoryFile; // 显示导入层次结构的树结构\n}\n"})}),"\n",(0,n.jsxs)(d.h3,{id:"memoryfile",children:[(0,n.jsx)(d.code,{children:"MemoryFile"}),(0,n.jsx)(d.a,{className:"header-anchor","aria-hidden":"true",href:"#memoryfile",children:"#"})]}),"\n",(0,n.jsx)(d.pre,{children:(0,n.jsx)(d.code,{className:"language-typescript",children:"interface MemoryFile {\n  path: string; // 文件路径\n  imports?: MemoryFile[]; // 直接导入，按导入顺序\n}\n"})}),"\n",(0,n.jsxs)(d.h3,{id:"validateimportpathimportpath-basepath-alloweddirectories",children:[(0,n.jsx)(d.code,{children:"validateImportPath(importPath, basePath, allowedDirectories)"}),(0,n.jsx)(d.a,{className:"header-anchor","aria-hidden":"true",href:"#validateimportpathimportpath-basepath-alloweddirectories",children:"#"})]}),"\n",(0,n.jsx)(d.p,{children:"验证导入路径以确保它们是安全的并在允许的目录内。"}),"\n",(0,n.jsx)(d.p,{children:(0,n.jsx)(d.strong,{children:"参数："})}),"\n",(0,n.jsxs)(d.ul,{children:["\n",(0,n.jsxs)(d.li,{children:[(0,n.jsx)(d.code,{children:"importPath"}),"（字符串）：要验证的导入路径"]}),"\n",(0,n.jsxs)(d.li,{children:[(0,n.jsx)(d.code,{children:"basePath"}),"（字符串）：用于解析相对路径的基目录"]}),"\n",(0,n.jsxs)(d.li,{children:[(0,n.jsx)(d.code,{children:"allowedDirectories"}),"（字符串数组）：允许的目录路径数组"]}),"\n"]}),"\n",(0,n.jsxs)(d.p,{children:[(0,n.jsx)(d.strong,{children:"返回："})," boolean - 导入路径是否有效"]}),"\n",(0,n.jsxs)(d.h3,{id:"findprojectrootstartdir",children:[(0,n.jsx)(d.code,{children:"findProjectRoot(startDir)"}),(0,n.jsx)(d.a,{className:"header-anchor","aria-hidden":"true",href:"#findprojectrootstartdir",children:"#"})]}),"\n",(0,n.jsxs)(d.p,{children:["通过从给定起始目录向上搜索 ",(0,n.jsx)(d.code,{children:".git"})," 目录来查找项目根目录。实现为",(0,n.jsx)(d.strong,{children:"异步"}),"函数，使用非阻塞文件系统 API 以避免阻塞 Node.js 事件循环。"]}),"\n",(0,n.jsx)(d.p,{children:(0,n.jsx)(d.strong,{children:"参数："})}),"\n",(0,n.jsxs)(d.ul,{children:["\n",(0,n.jsxs)(d.li,{children:[(0,n.jsx)(d.code,{children:"startDir"}),"（字符串）：开始搜索的目录"]}),"\n"]}),"\n",(0,n.jsxs)(d.p,{children:[(0,n.jsx)(d.strong,{children:"返回："})," Promise"," - 项目根目录（如果未找到 ",(0,n.jsx)(d.code,{children:".git"}),"，则为起始目录）"]}),"\n",(0,n.jsxs)(d.h2,{id:"最佳实践",children:["最佳实践",(0,n.jsx)(d.a,{className:"header-anchor","aria-hidden":"true",href:"#最佳实践",children:"#"})]}),"\n",(0,n.jsxs)(d.ol,{children:["\n",(0,n.jsx)(d.li,{children:(0,n.jsx)(d.strong,{children:"为导入组件使用描述性文件名"})}),"\n",(0,n.jsxs)(d.li,{children:[(0,n.jsx)(d.strong,{children:"保持导入浅层"})," - 避免深度嵌套的导入链"]}),"\n",(0,n.jsxs)(d.li,{children:[(0,n.jsx)(d.strong,{children:"记录您的结构"})," - 维护导入文件的清晰层次结构"]}),"\n",(0,n.jsxs)(d.li,{children:[(0,n.jsx)(d.strong,{children:"测试您的导入"})," - 确保所有引用的文件存在且可访问"]}),"\n",(0,n.jsxs)(d.li,{children:[(0,n.jsx)(d.strong,{children:"尽可能使用相对路径"})," 以获得更好的可移植性"]}),"\n"]}),"\n",(0,n.jsxs)(d.h2,{id:"故障排除",children:["故障排除",(0,n.jsx)(d.a,{className:"header-anchor","aria-hidden":"true",href:"#故障排除",children:"#"})]}),"\n",(0,n.jsxs)(d.h3,{id:"常见问题",children:["常见问题",(0,n.jsx)(d.a,{className:"header-anchor","aria-hidden":"true",href:"#常见问题",children:"#"})]}),"\n",(0,n.jsxs)(d.ol,{children:["\n",(0,n.jsxs)(d.li,{children:[(0,n.jsx)(d.strong,{children:"导入不工作"}),"：检查文件是否存在且路径正确"]}),"\n",(0,n.jsxs)(d.li,{children:[(0,n.jsx)(d.strong,{children:"循环导入警告"}),"：检查您的导入结构是否存在循环引用"]}),"\n",(0,n.jsxs)(d.li,{children:[(0,n.jsx)(d.strong,{children:"权限错误"}),"：确保文件可读且在允许的目录内"]}),"\n",(0,n.jsxs)(d.li,{children:[(0,n.jsx)(d.strong,{children:"路径解析问题"}),"：如果相对路径无法解析，请使用绝对路径"]}),"\n"]}),"\n",(0,n.jsxs)(d.h3,{id:"调试模式",children:["调试模式",(0,n.jsx)(d.a,{className:"header-anchor","aria-hidden":"true",href:"#调试模式",children:"#"})]}),"\n",(0,n.jsx)(d.p,{children:"启用调试模式以查看导入过程的详细日志记录："}),"\n",(0,n.jsx)(d.pre,{children:(0,n.jsx)(d.code,{className:"language-typescript",children:"const result = await processImports(content, basePath, true);\n"})})]})}function h(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:d}=Object.assign({},(0,s.ah)(),e.components);return d?(0,n.jsx)(d,{...e,children:(0,n.jsx)(i,{...e})}):i(e)}let a=h;h.__RSPRESS_PAGE_META={},h.__RSPRESS_PAGE_META["zh%2Fcore%2Fmemport.md"]={toc:[{text:"概述",id:"概述",depth:2},{text:"语法",id:"语法",depth:2},{text:"支持的路径格式",id:"支持的路径格式",depth:2},{text:"相对路径",id:"相对路径",depth:3},{text:"绝对路径",id:"绝对路径",depth:3},{text:"示例",id:"示例",depth:2},{text:"基本导入",id:"基本导入",depth:3},{text:"嵌套导入",id:"嵌套导入",depth:3},{text:"安全功能",id:"安全功能",depth:2},{text:"循环导入检测",id:"循环导入检测",depth:3},{text:"文件访问安全",id:"文件访问安全",depth:3},{text:"最大导入深度",id:"最大导入深度",depth:3},{text:"错误处理",id:"错误处理",depth:2},{text:"缺失文件",id:"缺失文件",depth:3},{text:"文件访问错误",id:"文件访问错误",depth:3},{text:"代码区域检测",id:"代码区域检测",depth:2},{text:"导入树结构",id:"导入树结构",depth:2},{text:"与 Claude Code 的 `/memory`（`claude.md`）方法的比较",id:"与-claude-code-的-memoryclaudemd方法的比较",depth:2},{text:"API 参考",id:"api-参考",depth:2},{text:"`processImports(content, basePath, debugMode?, importState?)`",id:"processimportscontent-basepath-debugmode-importstate",depth:3},{text:"`ProcessImportsResult`",id:"processimportsresult",depth:3},{text:"`MemoryFile`",id:"memoryfile",depth:3},{text:"`validateImportPath(importPath, basePath, allowedDirectories)`",id:"validateimportpathimportpath-basepath-alloweddirectories",depth:3},{text:"`findProjectRoot(startDir)`",id:"findprojectrootstartdir",depth:3},{text:"最佳实践",id:"最佳实践",depth:2},{text:"故障排除",id:"故障排除",depth:2},{text:"常见问题",id:"常见问题",depth:3},{text:"调试模式",id:"调试模式",depth:3}],title:"内存导入处理器",headingTitle:"内存导入处理器",frontmatter:{}}}}]);