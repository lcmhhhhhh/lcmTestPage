"use strict";(self.webpackChunklcm_test_page=self.webpackChunklcm_test_page||[]).push([["945"],{4924:function(e,s,n){n.r(s),n.d(s,{default:()=>r});var o=n(5893),i=n(65);function l(e){let s=Object.assign({h1:"h1",a:"a",p:"p",code:"code",h2:"h2",ul:"ul",li:"li",strong:"strong",ol:"ol"},(0,i.ah)(),e.components);return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsxs)(s.h1,{id:"gemini-cli-core-tools-api",children:["Gemini CLI Core: Tools API",(0,o.jsx)(s.a,{className:"header-anchor","aria-hidden":"true",href:"#gemini-cli-core-tools-api",children:"#"})]}),"\n",(0,o.jsxs)(s.p,{children:["The Gemini CLI core (",(0,o.jsx)(s.code,{children:"packages/core"}),") features a robust system for defining, registering, and executing tools. These tools extend the capabilities of the Gemini model, allowing it to interact with the local environment, fetch web content, and perform various actions beyond simple text generation."]}),"\n",(0,o.jsxs)(s.h2,{id:"core-concepts",children:["Core Concepts",(0,o.jsx)(s.a,{className:"header-anchor","aria-hidden":"true",href:"#core-concepts",children:"#"})]}),"\n",(0,o.jsxs)(s.ul,{children:["\n",(0,o.jsxs)(s.li,{children:["\n",(0,o.jsxs)(s.p,{children:[(0,o.jsxs)(s.strong,{children:["Tool (",(0,o.jsx)(s.code,{children:"tools.ts"}),"):"]})," An interface and base class (",(0,o.jsx)(s.code,{children:"BaseTool"}),") that defines the contract for all tools. Each tool must have:"]}),"\n",(0,o.jsxs)(s.ul,{children:["\n",(0,o.jsxs)(s.li,{children:[(0,o.jsx)(s.code,{children:"name"}),": A unique internal name (used in API calls to Gemini)."]}),"\n",(0,o.jsxs)(s.li,{children:[(0,o.jsx)(s.code,{children:"displayName"}),": A user-friendly name."]}),"\n",(0,o.jsxs)(s.li,{children:[(0,o.jsx)(s.code,{children:"description"}),": A clear explanation of what the tool does, which is provided to the Gemini model."]}),"\n",(0,o.jsxs)(s.li,{children:[(0,o.jsx)(s.code,{children:"parameterSchema"}),": A JSON schema defining the parameters that the tool accepts. This is crucial for the Gemini model to understand how to call the tool correctly."]}),"\n",(0,o.jsxs)(s.li,{children:[(0,o.jsx)(s.code,{children:"validateToolParams()"}),": A method to validate incoming parameters."]}),"\n",(0,o.jsxs)(s.li,{children:[(0,o.jsx)(s.code,{children:"getDescription()"}),": A method to provide a human-readable description of what the tool will do with specific parameters before execution."]}),"\n",(0,o.jsxs)(s.li,{children:[(0,o.jsx)(s.code,{children:"shouldConfirmExecute()"}),": A method to determine if user confirmation is required before execution (e.g., for potentially destructive operations)."]}),"\n",(0,o.jsxs)(s.li,{children:[(0,o.jsx)(s.code,{children:"execute()"}),": The core method that performs the tool's action and returns a ",(0,o.jsx)(s.code,{children:"ToolResult"}),"."]}),"\n"]}),"\n"]}),"\n",(0,o.jsxs)(s.li,{children:["\n",(0,o.jsxs)(s.p,{children:[(0,o.jsxs)(s.strong,{children:[(0,o.jsx)(s.code,{children:"ToolResult"})," (",(0,o.jsx)(s.code,{children:"tools.ts"}),"):"]})," An interface defining the structure of a tool's execution outcome:"]}),"\n",(0,o.jsxs)(s.ul,{children:["\n",(0,o.jsxs)(s.li,{children:[(0,o.jsx)(s.code,{children:"llmContent"}),": The factual content to be included in the history sent back to the LLM for context. This can be a simple string or a ",(0,o.jsx)(s.code,{children:"PartListUnion"})," (an array of ",(0,o.jsx)(s.code,{children:"Part"})," objects and strings) for rich content."]}),"\n",(0,o.jsxs)(s.li,{children:[(0,o.jsx)(s.code,{children:"returnDisplay"}),": A user-friendly string (often Markdown) or a special object (like ",(0,o.jsx)(s.code,{children:"FileDiff"}),") for display in the CLI."]}),"\n"]}),"\n"]}),"\n",(0,o.jsxs)(s.li,{children:["\n",(0,o.jsxs)(s.p,{children:[(0,o.jsx)(s.strong,{children:"Returning Rich Content:"})," Tools are not limited to returning simple text. The ",(0,o.jsx)(s.code,{children:"llmContent"})," can be a ",(0,o.jsx)(s.code,{children:"PartListUnion"}),", which is an array that can contain a mix of ",(0,o.jsx)(s.code,{children:"Part"})," objects (for images, audio, etc.) and ",(0,o.jsx)(s.code,{children:"string"}),"s. This allows a single tool execution to return multiple pieces of rich content."]}),"\n"]}),"\n",(0,o.jsxs)(s.li,{children:["\n",(0,o.jsxs)(s.p,{children:[(0,o.jsxs)(s.strong,{children:["Tool Registry (",(0,o.jsx)(s.code,{children:"tool-registry.ts"}),"):"]})," A class (",(0,o.jsx)(s.code,{children:"ToolRegistry"}),") responsible for:"]}),"\n",(0,o.jsxs)(s.ul,{children:["\n",(0,o.jsxs)(s.li,{children:[(0,o.jsx)(s.strong,{children:"Registering Tools:"})," Holding a collection of all available built-in tools (e.g., ",(0,o.jsx)(s.code,{children:"ReadFileTool"}),", ",(0,o.jsx)(s.code,{children:"ShellTool"}),")."]}),"\n",(0,o.jsxs)(s.li,{children:[(0,o.jsx)(s.strong,{children:"Discovering Tools:"})," It can also discover tools dynamically:","\n",(0,o.jsxs)(s.ul,{children:["\n",(0,o.jsxs)(s.li,{children:[(0,o.jsx)(s.strong,{children:"Command-based Discovery:"})," If ",(0,o.jsx)(s.code,{children:"tools.discoveryCommand"})," is configured in settings, this command is executed. It's expected to output JSON describing custom tools, which are then registered as ",(0,o.jsx)(s.code,{children:"DiscoveredTool"})," instances."]}),"\n",(0,o.jsxs)(s.li,{children:[(0,o.jsx)(s.strong,{children:"MCP-based Discovery:"})," If ",(0,o.jsx)(s.code,{children:"mcp.serverCommand"})," is configured, the registry can connect to a Model Context Protocol (MCP) server to list and register tools (",(0,o.jsx)(s.code,{children:"DiscoveredMCPTool"}),")."]}),"\n"]}),"\n"]}),"\n",(0,o.jsxs)(s.li,{children:[(0,o.jsx)(s.strong,{children:"Providing Schemas:"})," Exposing the ",(0,o.jsx)(s.code,{children:"FunctionDeclaration"})," schemas of all registered tools to the Gemini model, so it knows what tools are available and how to use them."]}),"\n",(0,o.jsxs)(s.li,{children:[(0,o.jsx)(s.strong,{children:"Retrieving Tools:"})," Allowing the core to get a specific tool by name for execution."]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,o.jsxs)(s.h2,{id:"built-in-tools",children:["Built-in Tools",(0,o.jsx)(s.a,{className:"header-anchor","aria-hidden":"true",href:"#built-in-tools",children:"#"})]}),"\n",(0,o.jsxs)(s.p,{children:["The core comes with a suite of pre-defined tools, typically found in ",(0,o.jsx)(s.code,{children:"packages/core/src/tools/"}),". These include:"]}),"\n",(0,o.jsxs)(s.ul,{children:["\n",(0,o.jsxs)(s.li,{children:[(0,o.jsx)(s.strong,{children:"File System Tools:"}),"\n",(0,o.jsxs)(s.ul,{children:["\n",(0,o.jsxs)(s.li,{children:[(0,o.jsx)(s.code,{children:"LSTool"})," (",(0,o.jsx)(s.code,{children:"ls.ts"}),"): Lists directory contents."]}),"\n",(0,o.jsxs)(s.li,{children:[(0,o.jsx)(s.code,{children:"ReadFileTool"})," (",(0,o.jsx)(s.code,{children:"read-file.ts"}),"): Reads the content of a single file. It takes an ",(0,o.jsx)(s.code,{children:"absolute_path"})," parameter, which must be an absolute path."]}),"\n",(0,o.jsxs)(s.li,{children:[(0,o.jsx)(s.code,{children:"WriteFileTool"})," (",(0,o.jsx)(s.code,{children:"write-file.ts"}),"): Writes content to a file."]}),"\n",(0,o.jsxs)(s.li,{children:[(0,o.jsx)(s.code,{children:"GrepTool"})," (",(0,o.jsx)(s.code,{children:"grep.ts"}),"): Searches for patterns in files."]}),"\n",(0,o.jsxs)(s.li,{children:[(0,o.jsx)(s.code,{children:"GlobTool"})," (",(0,o.jsx)(s.code,{children:"glob.ts"}),"): Finds files matching glob patterns."]}),"\n",(0,o.jsxs)(s.li,{children:[(0,o.jsx)(s.code,{children:"EditTool"})," (",(0,o.jsx)(s.code,{children:"edit.ts"}),"): Performs in-place modifications to files (often requiring confirmation)."]}),"\n",(0,o.jsxs)(s.li,{children:[(0,o.jsx)(s.code,{children:"ReadManyFilesTool"})," (",(0,o.jsx)(s.code,{children:"read-many-files.ts"}),"): Reads and concatenates content from multiple files or glob patterns (used by the ",(0,o.jsx)(s.code,{children:"@"})," command in CLI)."]}),"\n"]}),"\n"]}),"\n",(0,o.jsxs)(s.li,{children:[(0,o.jsx)(s.strong,{children:"Execution Tools:"}),"\n",(0,o.jsxs)(s.ul,{children:["\n",(0,o.jsxs)(s.li,{children:[(0,o.jsx)(s.code,{children:"ShellTool"})," (",(0,o.jsx)(s.code,{children:"shell.ts"}),"): Executes arbitrary shell commands (requires careful sandboxing and user confirmation)."]}),"\n"]}),"\n"]}),"\n",(0,o.jsxs)(s.li,{children:[(0,o.jsx)(s.strong,{children:"Web Tools:"}),"\n",(0,o.jsxs)(s.ul,{children:["\n",(0,o.jsxs)(s.li,{children:[(0,o.jsx)(s.code,{children:"WebFetchTool"})," (",(0,o.jsx)(s.code,{children:"web-fetch.ts"}),"): Fetches content from a URL."]}),"\n",(0,o.jsxs)(s.li,{children:[(0,o.jsx)(s.code,{children:"WebSearchTool"})," (",(0,o.jsx)(s.code,{children:"web-search.ts"}),"): Performs a web search."]}),"\n"]}),"\n"]}),"\n",(0,o.jsxs)(s.li,{children:[(0,o.jsx)(s.strong,{children:"Memory Tools:"}),"\n",(0,o.jsxs)(s.ul,{children:["\n",(0,o.jsxs)(s.li,{children:[(0,o.jsx)(s.code,{children:"MemoryTool"})," (",(0,o.jsx)(s.code,{children:"memoryTool.ts"}),"): Interacts with the AI's memory."]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,o.jsxs)(s.p,{children:["Each of these tools extends ",(0,o.jsx)(s.code,{children:"BaseTool"})," and implements the required methods for its specific functionality."]}),"\n",(0,o.jsxs)(s.h2,{id:"tool-execution-flow",children:["Tool Execution Flow",(0,o.jsx)(s.a,{className:"header-anchor","aria-hidden":"true",href:"#tool-execution-flow",children:"#"})]}),"\n",(0,o.jsxs)(s.ol,{children:["\n",(0,o.jsxs)(s.li,{children:[(0,o.jsx)(s.strong,{children:"Model Request:"})," The Gemini model, based on the user's prompt and the provided tool schemas, decides to use a tool and returns a ",(0,o.jsx)(s.code,{children:"FunctionCall"})," part in its response, specifying the tool name and arguments."]}),"\n",(0,o.jsxs)(s.li,{children:[(0,o.jsx)(s.strong,{children:"Core Receives Request:"})," The core parses this ",(0,o.jsx)(s.code,{children:"FunctionCall"}),"."]}),"\n",(0,o.jsxs)(s.li,{children:[(0,o.jsx)(s.strong,{children:"Tool Retrieval:"})," It looks up the requested tool in the ",(0,o.jsx)(s.code,{children:"ToolRegistry"}),"."]}),"\n",(0,o.jsxs)(s.li,{children:[(0,o.jsx)(s.strong,{children:"Parameter Validation:"})," The tool's ",(0,o.jsx)(s.code,{children:"validateToolParams()"})," method is called."]}),"\n",(0,o.jsxs)(s.li,{children:[(0,o.jsx)(s.strong,{children:"Confirmation (if needed):"}),"\n",(0,o.jsxs)(s.ul,{children:["\n",(0,o.jsxs)(s.li,{children:["The tool's ",(0,o.jsx)(s.code,{children:"shouldConfirmExecute()"})," method is called."]}),"\n",(0,o.jsx)(s.li,{children:"If it returns details for confirmation, the core communicates this back to the CLI, which prompts the user."}),"\n",(0,o.jsx)(s.li,{children:"The user's decision (e.g., proceed, cancel) is sent back to the core."}),"\n"]}),"\n"]}),"\n",(0,o.jsxs)(s.li,{children:[(0,o.jsx)(s.strong,{children:"Execution:"})," If validated and confirmed (or if no confirmation is needed), the core calls the tool's ",(0,o.jsx)(s.code,{children:"execute()"})," method with the provided arguments and an ",(0,o.jsx)(s.code,{children:"AbortSignal"})," (for potential cancellation)."]}),"\n",(0,o.jsxs)(s.li,{children:[(0,o.jsx)(s.strong,{children:"Result Processing:"})," The ",(0,o.jsx)(s.code,{children:"ToolResult"})," from ",(0,o.jsx)(s.code,{children:"execute()"})," is received by the core."]}),"\n",(0,o.jsxs)(s.li,{children:[(0,o.jsx)(s.strong,{children:"Response to Model:"})," The ",(0,o.jsx)(s.code,{children:"llmContent"})," from the ",(0,o.jsx)(s.code,{children:"ToolResult"})," is packaged as a ",(0,o.jsx)(s.code,{children:"FunctionResponse"})," and sent back to the Gemini model so it can continue generating a user-facing response."]}),"\n",(0,o.jsxs)(s.li,{children:[(0,o.jsx)(s.strong,{children:"Display to User:"})," The ",(0,o.jsx)(s.code,{children:"returnDisplay"})," from the ",(0,o.jsx)(s.code,{children:"ToolResult"})," is sent to the CLI to show the user what the tool did."]}),"\n"]}),"\n",(0,o.jsxs)(s.h2,{id:"extending-with-custom-tools",children:["Extending with Custom Tools",(0,o.jsx)(s.a,{className:"header-anchor","aria-hidden":"true",href:"#extending-with-custom-tools",children:"#"})]}),"\n",(0,o.jsx)(s.p,{children:"While direct programmatic registration of new tools by users isn't explicitly detailed as a primary workflow in the provided files for typical end-users, the architecture supports extension through:"}),"\n",(0,o.jsxs)(s.ul,{children:["\n",(0,o.jsxs)(s.li,{children:[(0,o.jsx)(s.strong,{children:"Command-based Discovery:"})," Advanced users or project administrators can define a ",(0,o.jsx)(s.code,{children:"tools.discoveryCommand"})," in ",(0,o.jsx)(s.code,{children:"settings.json"}),". This command, when run by the Gemini CLI core, should output a JSON array of ",(0,o.jsx)(s.code,{children:"FunctionDeclaration"})," objects. The core will then make these available as ",(0,o.jsx)(s.code,{children:"DiscoveredTool"})," instances. The corresponding ",(0,o.jsx)(s.code,{children:"tools.callCommand"})," would then be responsible for actually executing these custom tools."]}),"\n",(0,o.jsxs)(s.li,{children:[(0,o.jsx)(s.strong,{children:"MCP Server(s):"})," For more complex scenarios, one or more MCP servers can be set up and configured via the ",(0,o.jsx)(s.code,{children:"mcpServers"})," setting in ",(0,o.jsx)(s.code,{children:"settings.json"}),". The Gemini CLI core can then discover and use tools exposed by these servers. As mentioned, if you have multiple MCP servers, the tool names will be prefixed with the server name from your configuration (e.g., ",(0,o.jsx)(s.code,{children:"serverAlias__actualToolName"}),")."]}),"\n"]}),"\n",(0,o.jsx)(s.p,{children:"This tool system provides a flexible and powerful way to augment the Gemini model's capabilities, making the Gemini CLI a versatile assistant for a wide range of tasks."})]})}function t(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:s}=Object.assign({},(0,i.ah)(),e.components);return s?(0,o.jsx)(s,{...e,children:(0,o.jsx)(l,{...e})}):l(e)}let r=t;t.__RSPRESS_PAGE_META={},t.__RSPRESS_PAGE_META["core%2Ftools-api.md"]={toc:[{text:"Core Concepts",id:"core-concepts",depth:2},{text:"Built-in Tools",id:"built-in-tools",depth:2},{text:"Tool Execution Flow",id:"tool-execution-flow",depth:2},{text:"Extending with Custom Tools",id:"extending-with-custom-tools",depth:2}],title:"Gemini CLI Core: Tools API",headingTitle:"Gemini CLI Core: Tools API",frontmatter:{}}}}]);